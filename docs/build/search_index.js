var documenterSearchIndex = {"docs":
[{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"using Karnak, Luxor, Graphs, NetworkLayout, Colors, SimpleWeightedGraphs","category":"page"},{"location":"basics.html#Tutorial","page":"Basic graphs","title":"Tutorial","text":"","category":"section"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"This section contains an introduction to basic graph theory using the Graphs.jl package. You don't need any prior knowledge of graphs, but you should be familiar with the basics of programming in Julia.","category":"page"},{"location":"basics.html#Graphs,-vertices,-and-edges","page":"Basic graphs","title":"Graphs, vertices, and edges","text":"","category":"section"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"Graph theory is used for analysing networks and the relationships between things in the network.","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"using Karnak, Luxor, Graphs, NetworkLayout, Colors, SimpleWeightedGraphs\nd = @drawsvg begin\n    background(\"grey10\")\n    sethue(\"yellow\")\n    fontsize(12)\n    g = Graph(3, 3)\n    add_vertex!(g)\n    add_edge!(g, 3, 4)\n    drawgraph(g,\n        layout=spring,\n        margin=50,\n        edgecurvature=0.2,\n        edgegaps=25,\n        edgestrokeweights=2,\n        vertexlabels = (v) -> \"thing $(v)\",\n        vertexshapes = [:circle, :square],\n        vertexfillcolors = [RGB(Luxor.julia_red...), RGB(Luxor.julia_purple...), RGB(Luxor.julia_green...), RGB(Luxor.julia_blue...)],\n        vertexshapesizes = 25,\n        vertexlabeltextcolors = colorant\"white\",\n        edgelabels = (n, s, d, f, t) -> begin\n                θ = slope(f, t)\n                fontsize(15)\n                translate(midpoint(f, t))\n                rotate(θ)\n                label([\"relationship\", \"relationship\", \"relationship\", \"relationship\"][n], [:n, :n, :s, :n][n], O, offset=10)\n            end,\n        )\nend 600 350","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"d # hide","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"A typical graph consists of:","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"vertices, which represent the things or entities, and\nedges, which describe how these things or entities connect and relate to each other","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"The Graphs.jl package provides many ways to create graphs. We'll start off with this basic approach:","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"using Graphs\ng = Graph()","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"The Graph() function creates a new empty graph and stores it in g. (You can use SimpleGraph() as well as Graph().) Let's add a single vertex:","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"add_vertex!(g)","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"We can easily add a number of new vertices:","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"add_vertices!(g, 3)","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"Now we'll join pairs of vertices with an edge. The four vertices we've made can be referred to with 1, 2, 3, and 4:","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"add_edge!(g, 1, 2)  # join vertex 1 with vertex 2\nadd_edge!(g, 1, 3)\nadd_edge!(g, 2, 3)\nadd_edge!(g, 1, 4)","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"g is now a {{4, 1} undirected simple Int64 graph}. It's time to see some kind of visual representation of the graph we've made.","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"# packages to load:\n# using Karnak, Luxor, Graphs, NetworkLayout, Colors, SimpleWeightedGraphs\n\ng = Graph()\nadd_vertices!(g, 4)\nadd_edge!(g, 1, 2)\nadd_edge!(g, 1, 3)\nadd_edge!(g, 2, 3)\nadd_edge!(g, 1, 4)\n\n@drawsvg begin\n    background(\"grey10\")\n    sethue(\"orange\")\n    drawgraph(g, vertexlabels = [1, 2, 3, 4])\nend 600 300","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"This is one of the many ways this graph can be represented visually. The coordinates of the vertices when drawn here are not part of the graph's definition, and have been assigned randomly by the layout algorithm.","category":"page"},{"location":"basics.html#Undirected-and-directed-graphs","page":"Basic graphs","title":"Undirected and directed graphs","text":"","category":"section"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"We'll meet two main types of graph, undirected and directed. In our undirected graph g above, vertex 1 and vertex 2 are neighbors, connected by an edge, but there's no way to specify or see a direction for that connection. For example, if the graph was modelling people making financial transactions, we couldn't tell whether the person at vertex 1 sent money to the person at vertex 2, or received money from them.","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"In Graphs.jl, we can create directed graphs with DiGraph() (also SimpleDiGraph()).","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"gd = DiGraph()\nadd_vertices!(gd, 4)\nadd_edge!(gd, 1, 2)\nadd_edge!(gd, 1, 3)\nadd_edge!(gd, 2, 3)\nadd_edge!(gd, 1, 4) # vertex 1 to vertex 4\nadd_edge!(gd, 4, 1) # vertex 4 to vertex 1\n\n@drawsvg begin\nbackground(\"grey10\")\nsethue(\"slateblue\")\ndrawgraph(gd, vertexlabels = [1, 2, 3, 4])\nend 600 300","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"In this representation of our directed graph gd, we can now see the direction of the edges joining vertices. Notice how vertices 1 and 4 are doubly connected, because there's one edge for each direction.","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"Neither of these graphs is connected. In a connected graph, every vertex is connected to every other via some path, a sequence of edges.","category":"page"},{"location":"basics.html#Very-simple-graphs","page":"Basic graphs","title":"Very simple graphs","text":"","category":"section"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"Creating graphs by typing the connections manually is tedious, so we usually use the Graph/SimpleGraph and DiGraph/SimpleDiGraph constructors:","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"g = Graph(10, 5) # 10 vertices, 5 edges\n\nd1 = @drawsvg begin\nbackground(\"grey10\")\nsethue(\"gold\")\ndrawgraph(g, vertexlabels = 1:nv(g))\nend 400 300\n\ngd = SimpleDiGraph(5, 3) # 5 vertices, 3, edges\n\nd2 = @drawsvg begin\nbackground(\"grey10\")\nsetline(0.5)\nsethue(\"firebrick\")\ndrawgraph(gd, vertexlabels = 1:nv(g))\nend 400 300\n\nhcat(d1, d2)","category":"page"},{"location":"basics.html#Well-known-graphs","page":"Basic graphs","title":"Well-known graphs","text":"","category":"section"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"Graphs have been studied for a few centuries, so there are many familiar and well-known graphs and types of graph.","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"In a complete graph, every vertex is connected to every other vertex.","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"N = 10\ng = complete_graph(N)\nd1 = @drawsvg begin\nbackground(\"grey10\")\nsetline(0.5)\nsethue(\"maroon\")\ndrawgraph(g, vertexlabels = 1:nv(g))\nend 600 300","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"There's also a complete_digraph() function.","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"N = 7\ng = complete_digraph(N)\nd1 = @drawsvg begin\nbackground(\"grey10\")\nsetline(0.5)\nsethue(\"orange\")\ndrawgraph(g, vertexlabels = 1:nv(g))\nend 600 300","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"In a bi-partite graph, every vertex belongs to one of two groups. Every vertex in the first group is connected to one or more edges in the second group. This illustration shows a complete bi-partite graph. The word \"complete\" here means that each vertex is connected to every other vertex.","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"N = 10\ng = complete_bipartite_graph(N, N)\nH = 300\nW = 550\nd1 = @drawsvg begin\nbackground(\"grey10\")\npts = vcat(\n    between.(O + (-W/2, H/2), O + (W/2, H/2), range(0, 1, length=N)),\n    between.(O + (-W/2, -H/2), O + (W/2, -H/2), range(0, 1, length=N)))\nsethue(\"gold3\")\ndrawgraph(g, vertexlabels = 1:nv(g), layout = pts, edgestrokeweights=0.5)\nend 600 400","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"A grid graph doesn't need much explanation:","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"M = 4\nN = 5\ng = Graphs.grid([M, N]) # grid((m, n))\nd1 = @drawsvg begin\nbackground(\"grey10\")\nsetline(0.5)\nsethue(\"orange\")\ndrawgraph(g, vertexlabels = 1:nv(g), layout=stress)\nend 600 300","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"Star graphs (star_graph(n)) and wheel graphs (wheel_graph(n)) deliver what their names promise.","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"g = star_graph(12)\nd1 = @drawsvg begin\n    background(\"grey10\")\n    sethue(\"orange\")\n    drawgraph(g, vertexlabels=1:nv(g), layout=stress)\nend 600 300","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"g = wheel_graph(12)\nd1 = @drawsvg begin\n    background(\"grey10\")\n    sethue(\"orange\")\n    drawgraph(g, vertexlabels=1:nv(g), layout=stress)\nend 600 300","category":"page"},{"location":"basics.html#Even-more-well-known-graphs","page":"Basic graphs","title":"Even more well-known graphs","text":"","category":"section"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"There are probably as many graphs as there are possible games of chess. In both fields, the more commonly-seen patterns have been studied extensively by enthusiasts for years.","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"Many well-known graphs are provided by the smallgraph() function. Supply one of the available symbols, such as :bull, or :house.","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"using Karnak, Luxor, Graphs, NetworkLayout\nsmallgraphs = (\n(:bull, \"bull\"),\n(:chvatal, \"chvatal\"),\n(:cubical, \"(Platonic) cubical \"),\n(:desargues, \"desarguesg\"),\n(:diamond, \"diamond\"),\n(:dodecahedral, \"(Platonic) dodecahedral\"),\n(:frucht, \"frucht\"),\n(:heawood, \"heawood\"),\n(:house, \"house\"),\n(:housex, \"housex \"),\n(:icosahedral, \"(Platonic) icosahedral\"),\n(:karate, \"karate\"),\n(:krackhardtkite, \"krackhardtkite\"),\n(:moebiuskantor, \"moebiusantor\"),\n(:octahedral, \"(platonic) octahedral\"),\n(:pappus, \"pappus\"),\n(:petersen, \"petersen\"),\n(:sedgewickmaze, \"sedgewick\"),\n(:tetrahedral, \"(Platonic) tetrahedral\"),\n(:truncatedcube, \"truncatedcube\"),\n(:truncatedtetrahedron, \"truncatedtetrahedron\"),\n(:truncatedtetrahedron_dir, \"truncatedtetrahedron\"),\n(:tutte, \"tutte\"))\n\ncolors = [\"orange\", \"brown1\", \"firebrick1\",\n\"blue\", \"red\", \"purple1\", \"royalblue1\",\n\"orangered\", \"orangered1\", \"deeppink\", \"deeppink1\", \"maroon1\",\n\"darkorchid1\", \"dodgerblue\", \"dodgerblue1\", \"blue2\",\n\"purple2\", \"royalblue2\", \"dodgerblue2\", \"slateblue2\",\n\"mediumslateblue\", \"darkorchid2\", \"violetred2\", \"maroon2\",\n\"orangered2\", \"brown2\"]\n\nsmallgraphs = @drawsvg begin\nbackground(\"grey10\")\nsethue(\"orange\")\nng = length(smallgraphs)\nN = convert(Int, ceil(sqrt(ng)))\ntiles = Tiler(800, 800, N, N)\nsetline(0.5)\nfor (pos, n) in tiles\n@layer begin\nn > ng && break\ntranslate(pos)\nsethue(colors[mod1(n, end)])\nbbox = BoundingBox(box(O, tiles.tilewidth, tiles.tileheight))\ng = smallgraph(first(smallgraphs[n]))\ndrawgraph(g, boundingbox=bbox, vertexshapesizes = 2, layout = stress)\nsethue(\"cyan\")\ntext(string(last(smallgraphs[n])), halign=:center, boxbottomcenter(bbox))\nend\nend\nend 800 800","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"smallgraphs # hide","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"It's easy to find out more about these well-known graphs online, such as on the wikipedia. Some of the graphs in this illustration would benefit from attentive ‘tuning’ of the various layout parameters.","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"Here's a larger view of the Petersen graph (named after Julius Petersen, who first described it in 1898).","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"@drawsvg begin\nbackground(\"grey10\")\npg = smallgraph(:petersen)\nsethue(\"orange\")\ndrawgraph(pg, vertexlabels = 1:nv(pg), layout = Shell(nlist=[6:10,]))\nend 600 300","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"@drawsvg begin\nbackground(\"grey10\")\ng = smallgraph(:cubical)\nsethue(\"orange\")\ndrawgraph(g, layout = Spring(Ptype=Float64))\nend 600 300","category":"page"},{"location":"basics.html#Getting-some-information-about-the-graph","page":"Basic graphs","title":"Getting some information about the graph","text":"","category":"section"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"There are lots of functions for obtaining information about a graph.","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"How many vertices?","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"julia> nv(pg)\n6","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"How many edges?","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"julia> ne(pg)\n15","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"Which vertices are connected with vertex 1? - ie what are the neighbors of a particular vertex?","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"julia> neighbors(pg, 1)\n5-element Vector{Int64}:\n 2\n 3\n 4\n 5\n 6","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"We can iterate over vertices and edges. To step through each vertex:","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"for e in vertices(pg)\n    println(e)\nend\n\n1\n2\n3\n4\n5\n6","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"Iterating over edges will give a value of type Edge, and the src() and and dst() functions applied to an edge argument return the numbers of the source and destination vertices respectively.","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"for e in edges(pg)\n    println(src(e), \" => \", dst(e))\nend\n1 => 2\n1 => 5\n1 => 6\n2 => 3\n2 => 7\n3 => 4\n3 => 8\n4 => 5\n4 => 9\n5 => 10\n6 => 8\n6 => 9\n7 => 9\n7 => 10\n8 => 10","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"To add an edge, do:","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"add_edge!(df, 1, 2) # from vertex 1 to 2","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"It's sometimes useful to be able to see these relationships between neighbors visually.","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"@drawsvg begin\nbackground(\"grey10\")\npg = smallgraph(:petersen)\n\nvertexofinterest = 10\nE = []\nfor (n, e) in enumerate(edges(pg))\n    if dst(e) == vertexofinterest || src(e) == vertexofinterest\n        push!(E, n)\n    end\nend\n\ndrawgraph(pg,\n    vertexlabels = 1:nv(pg),\n    layout = Shell(nlist=[6:10,]),\n    vertexfillcolors = (v) -> ((v == vertexofinterest) || v ∈ neighbors(pg, vertexofinterest)) && colorant\"blue\",\n    vertexshapesizes = [v == vertexofinterest ? 20 : 10 for v in 1:nv(pg)],\n    edgestrokecolors = (e, f, t, s, d) -> (e ∈ E) ? colorant\"red\" : colorant\"blue\"\n    )\nend 600 300","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"Other useful functions in Graphs.jl include has_vertex(g, v) and has_edge(g, s, d).","category":"page"},{"location":"basics.html#Degree","page":"Basic graphs","title":"Degree","text":"","category":"section"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"The degree of a vertex is the number of edges that meet at that vertex.","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"@draw begin\nbackground(\"grey10\")\nsethue(\"gold\")\ng = smallgraph(:krackhardtkite)\n\ndrawgraph(g, layout=spring,\n    vertexfillcolors = (vtx) -> distinguishable_colors(nv(g), transform=tritanopic)[degree(g, vtx)],\n    vertexshapesizes = 20,\n    margin=40,\n    vertexlabels = (vtx) -> string(degree(g, vtx)),\n    vertexlabelfontsizes = 20,\n    vertexlabeltextcolors = [colorant\"black\", colorant\"white\"]\n    )\nend 600 300","category":"page"},{"location":"basics.html#Graphs-as-matrices","page":"Basic graphs","title":"Graphs as matrices","text":"","category":"section"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"Graphs can be represented as matrices. In the world of graph theory, we'll meet the adjacency matrix, the incidence matrix, and the adjacency list.","category":"page"},{"location":"basics.html#Adjacency-matrix","page":"Basic graphs","title":"Adjacency matrix","text":"","category":"section"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"A graph G with n vertices can be represented by a square matrix A with n rows and columns. The matrix consists of 1s and 0s. A value of 1 means that there's a connection between two vertices with those indices. For example, if vertex 5 is connected with vertex 4, then A[5, 4] is 1. The adjacency_matrix() function displays the matrix for a graph:","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"julia> adjacency_matrix(pg)\n10×10 SparseArrays.SparseMatrixCSC{Int64, Int64} with 30 stored entries:\n ⋅  1  ⋅  ⋅  1  1  ⋅  ⋅  ⋅  ⋅\n 1  ⋅  1  ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅\n ⋅  1  ⋅  1  ⋅  ⋅  ⋅  1  ⋅  ⋅\n ⋅  ⋅  1  ⋅  1  ⋅  ⋅  ⋅  1  ⋅\n 1  ⋅  ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  1\n 1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  1  ⋅\n ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  1\n ⋅  ⋅  1  ⋅  ⋅  1  ⋅  ⋅  ⋅  1\n ⋅  ⋅  ⋅  1  ⋅  1  1  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  1  ⋅  1  1  ⋅  ⋅","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"@drawsvg begin\nbackground(\"grey10\")\npg = smallgraph(:petersen)\nsethue(\"orange\")\ndrawgraph(pg, vertexlabels = 1:nv(pg), layout = Shell(nlist=[6:10,]))\nend 600 400","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"Notice that this matrix, for a Petersen graph, is symmetrical about the top-left/bottom-right diagonal, because, in an undirected graph, a connection from vertex 4 to vertex 5 is also a connection from vertex 5 to 4. The vertical sum of each column (and the horizontal sum of each row) is the number of edges shared by that vertex,","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"We can provide an adjacency matrix to the graph construction functions to create a graph. For example, this matrix recreates the House graph from its adjacency matrix:","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"m = [0 1 1 0 0;\n     1 0 0 1 0;\n     1 0 0 1 1;\n     0 1 1 0 1;\n     0 0 1 1 0]\n\n@drawsvg begin\nbackground(\"grey10\")\nhg = Graph(m)\nsethue(\"orange\")\ndrawgraph(hg, vertexlabels=1:nv(hg), layout=stress)\nend 800 400","category":"page"},{"location":"basics.html#Incidence-matrix","page":"Basic graphs","title":"Incidence matrix","text":"","category":"section"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"We can also represent a graph G with a matrix M consisting of 1s, -1s, and 0s in which the rows are vertices and the columns are edges. M is called an incidence matrix.","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"julia> incidence_matrix(pg)\n10×15 SparseArrays.SparseMatrixCSC{Int64, Int64} with 30 stored entries:\n 1  1  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n 1  ⋅  ⋅  1  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  1  ⋅  1  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅  1  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  1  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  1  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅  1\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅  1  1  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅  1  1","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"The first column of this matrix is an edge between vertex 1 and vertex 2, whereas the first column of the adjacency matrix defines the vertices that are connected with vertex 1.","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"For a directed graph:","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"julia> dg = DiGraph(3, 3)\n\njulia> incidence_matrix(dg)\n\n3×3 SparseArrays.SparseMatrixCSC{Int64, Int64} with 6 stored entries:\n -1   1   1\n  1  -1   ⋅\n  ⋅   ⋅  -1","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"Here, negative values are used, so 1 and -1 are used to indicate directions. The first column,-1 1 0, specifies the first edge goes from 2 to 1.","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"An incidence matrix is another useful way of quickly defining a graph. That's why we can pass an incidence matrix to the Graph() and DiGraph() functions to create new graphs.","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"For example, here's a vaguely familiar image:","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"g = [0 1 1;\n     1 0 1;\n     1 1 0]\n\n@drawsvg begin\nbackground(\"grey20\")\ndrawgraph(Graph(g),\n    layout = ngon(O + (0, 20), 80, 3, π/6, vertices=true),\n    vertexshapes = :circle,\n    vertexshapesizes = 40,\n    edgestrokeweights = 15,\n    edgestrokecolors = colorant\"gold\",\n    vertexfillcolors = [colorant\"#CB3C33\", colorant\"#389826\", colorant\"#9558B2\"])\nend 600 250","category":"page"},{"location":"basics.html#Adjacency-list","page":"Basic graphs","title":"Adjacency list","text":"","category":"section"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"Another way of representing a graph is by using an array of arrays in the form of an adjacency list. This array has n elements to represent a graph with n vertices. The first element of the array is an array of those vertex numbers that are connected with vertex 1, and similarly for elements 2 to n.","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"For example, this adjacency list:","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"[\n    [2, 5, 7],  # row 1: vertex 1 connects with 2, 5, and 7\n    [1, 3, 9],\n    [2, 4, 11],\n    [3, 5, 13],\n    [1, 4, 15],\n    [7, 15, 20],\n    [1, 6, 8],\n    [7, 9, 16],\n    [2, 8, 10],\n    [9, 11, 17],\n    [3, 10, 12],\n    [11, 13, 18],\n    [4, 12, 14],\n    [13, 15, 19],\n    [5, 6, 14],\n    [8, 17, 20],\n    [10, 16, 18],\n    [12, 17, 19],\n    [14, 18, 20],\n    [6, 16, 19]\n]","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"defines a graph with 10 vertices, such that vertex 1 has edges joining it to vertices 2, 5, 6, and 10, and so on for each element of the whole array.","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"g = Graph(30, [\n[2, 5, 7],\n[1, 3, 9],\n[2, 4, 11],\n[3, 5, 13],\n[1, 4, 15],\n[7, 15, 20],\n[1, 6, 8],\n[7, 9, 16],\n[2, 8, 10],\n[9, 11, 17],\n[3, 10, 12],\n[11, 13, 18],\n[4, 12, 14],\n[13, 15, 19],\n[5, 6, 14],\n[8, 17, 20],\n[10, 16, 18],\n[12, 17, 19],\n[14, 18, 20],\n[6, 16, 19]])\n\n@drawsvg begin\nbackground(\"grey10\")\nsethue(\"orange\")\ndrawgraph(g, layout=stress)\nend 600 300","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"Graphs.jl uses adjacency lists internally. If we peek inside a graph and look at its fields, we'll see something like this, for a Directed Graph:","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"fieldnames(DiGraph)\n(:ne, :fadjlist, :badjlist)","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"Here, fadjlist is a forward adjacency list which defines how each vertex connects to other vertices, and badjlist is a backward adjacency list which defines how each vertex receives connections from other vertices.","category":"page"},{"location":"basics.html#Paths,-cycles,-routes,-and-traversals","page":"Basic graphs","title":"Paths, cycles, routes, and traversals","text":"","category":"section"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"Graphs help us answer questions about connectivity and relationships. For example, thinking of a railway network as a graph, with the stations as vertices, and the tracks as edges, we want to ask questions such as \"Can we get from A to B by train?\", which therefore becomes the question \"Are there sufficient edges between two vertices such that we can find a path that joins them?\".","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"Graphs.jl has many features for traversing graphs and finding paths. We can look at just a few of them here.","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"note: Note\nThe study of graphs uses a lot of terminology, and many of the terms also have informal and familiar meanings. Usually the informal meanings are reasonably accurate and appropriate, but note that the words also have more precise definitions in the literature.","category":"page"},{"location":"basics.html#Paths-and-cycles","page":"Basic graphs","title":"Paths and cycles","text":"","category":"section"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"A path is a sequence of edges between some start vertex and some end vertex, such that a continuous unbroken route is available.","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"A cycle is a path where the start and end vertices are the same - a closed path. These are also called circuits in some sources.","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"The cycle_basis() function finds all the cycles in a graph (at least, a basis, which is a minimal collection of cycles that can be added to make all the cycles). The result is an array of arrays of vertex numbers.","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"cycles = cycle_basis(g)\n\n11-element Vector{Vector{Int64}}:\n [13, 14, 15, 16, 17]\n [11, 10, 14, 15, 16, 17, 18, 19, 20, 1]\n [2, 9, 10, 14, 15, 16, 17, 18, 19, 20, 1]\n [8, 9, 10, 14, 15]\n [6, 7, 8, 15, 16]\n [2, 3, 7, 8, 15, 16, 17, 18, 19, 20, 1]\n [4, 3, 7, 8, 15, 16, 17, 18, 19, 20]\n [5, 6, 16, 17, 18]\n [12, 13, 17, 18, 19]\n [4, 5, 18, 19, 20]\n [11, 12, 19, 20, 1]","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"@drawsvg begin\nbackground(\"grey10\")\nsethue(\"magenta\")\npg = smallgraph(:petersen)\n\ncycles = cycle_basis(pg)\n\nfor (n, cycle) in enumerate(cycles)\n    sethue(HSB(rescale(n, 1, length(cycles), 0, 360), .7, .7))\n    drawgraph(pg,\n        layout = stress,\n        vertexshapes = :none,\n        edgestrokeweights = 3,\n        edgecurvature = 10,\n        edgelist = [Edge(cycle[i], cycle[mod1(i + 1, end)]) for i in 1:length(cycle)])\nend\nend 600 300","category":"page"},{"location":"basics.html#Shortest-paths:-the-A*-algorithm","page":"Basic graphs","title":"Shortest paths: the A* algorithm","text":"","category":"section"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"One way to find the shortest path between two vertices is to use the a_star() function, and provide the graph, the start vertex, and the end vertex. The function returns a list of edges.","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"(The unusual name of this function is just a reference to the name of the algorithm, A*, first published in 1968 by Peter Hart, Nils Nilsson, and Bertram Raphael.)","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"The function finds the shortest path and returns an array of edges that define the path.","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"@drawsvg begin\nbackground(\"grey10\")\nsethue(\"lemonchiffon\")\ng = binary_tree(5)\ndirg = SimpleDiGraph(collect(edges(g)))\nastar = a_star(dirg, 1, 21)\ndrawgraph(dirg, layout=buchheim,\n    vertexlabels = 1:nv(g),\n    vertexshapes = (vtx) -> box(O, 30, 20, :fill),\n    vertexlabelfontsizes = 16,\n    edgegaps=20,\n    edgestrokeweights= 5,\n    edgestrokecolors = (edgenumber, from, to, s, d) -> (s ∈ src.(astar) && d ∈ dst.(astar)) ?\n        colorant\"orange\" : colorant\"grey40\",\n    vertexfillcolors = (vtx) -> (vtx ∈ src.(astar) || vtx ∈ dst.(astar)) && colorant\"orange\"\n    )\nend 800 400","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"One use for the A* algorithm is for finding paths through mazes. In the next example, a grid graph is subjected to some random vandalism, removing quite a few edges. Then a route through the maze was easily found by a_star().","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"using Karnak, Luxor, Graphs, Colors, NetworkLayout, Random\n\nRandom.seed!(67)\n@drawsvg begin\nbackground(\"grey10\")\n\nW, H = 30, 30\ng = grid((W, H))\n\n# vandalize the grid:\nlet\n    c = 0\n    while c < 500\n        v = rand(1:W*H)\n        rem_edge!(g, v, [v-1, v+1, v-W, v+H][rand(1:end)]) && (c += 1)\n    end\nend\n\n# find a route\nastar = a_star(g, 1, W * H)\n\nsethue(\"grey30\")\ndrawgraph(g,\n    vertexshapes = :square,\n    layout=squaregrid,\n    edgegaps=0)\n\nsethue(\"orange\")\ndrawgraph(g,\n    vertexshapes = :none,\n    layout=squaregrid,\n    edgelist=astar,\n    edgegaps=0,\n    edgestrokeweights=5)\n\nend 600 600","category":"page"},{"location":"basics.html#Weighted-graphs","page":"Basic graphs","title":"Weighted graphs","text":"","category":"section"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"Up to now, our graphs have been like maps of train or metro networks, focusing on connections, rather than on, say, distances and journey times. Edges are effectively always one unit long. Shortest path calculations can't take into account the true length of edges. But some systems modelled by graphs require this knowledge, which is where weighted graphs are useful. A weighted graph, which can be either undirected or directed, has numeric values assigned to each edge. This value is called the \"weight\" of an edge, and they're usually positive integers, but can be anything.","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"The word \"weight\" is interpreted according to context and the nature of the system modelled by the graph. For example, a higher value for the weight of an edge could mean a longer journey time or more expensive fuel costs, for map-style graphs, but it could signify high attraction levels for a social network graph.","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"To use weighted graphs, we must install a separate package, SimpleWeightedGraphs.jl, and load it alongside Graphs.jl.","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"To create a new weighted graph:","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"using Graphs, SimpleWeightedGraphs\n\njulia> wg = SimpleWeightedGraph()","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"This creates a new, empty, weighted, undirected, graph. Or we can pass an existing graph to this function:","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"julia> wg = SimpleWeightedGraph(Graph(6, 15), 4.0)","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"To get the weights of a vertex, use:","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"julia> get_weight(wg, 1, 2)","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"You can change the weight of an edge with:","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"julia> add_edge!(graph, from, to, weight)","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"In this example, we set the default weight of every edge to 4.0 when the graph is created, and changed just one edge's weight:","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"wg = SimpleWeightedGraph(Graph(6, 15), 4.0)\nadd_edge!(wg, 1, 2, 10_000_000)\n@drawsvg begin\n    sethue(\"gold\")\n    drawgraph(wg, edgecurvature=10,\n        vertexlabels = 1:nv(wg),\n        edgelabels = [get_weight(wg, src(e), dst(e)) for e in edges(wg)],\n        edgegaps = 10,\n        edgelabelcolors =\n            [get_weight(wg, src(e), dst(e)) > 10 ?\n                colorant\"red\" : colorant\"green\" for e in edges(wg)])\nend 600 300","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"If you look at the graph's adjacency matrix, you'll see that the weights have replaced the 1s:","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"julia> adjacency_matrix(wg)\n6×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 30 stored entries:\n  ⋅     1.0e7  4.0  4.0  4.0  4.0\n 1.0e7   ⋅     4.0  4.0  4.0  4.0\n 4.0    4.0     ⋅   4.0  4.0  4.0\n 4.0    4.0    4.0   ⋅   4.0  4.0\n 4.0    4.0    4.0  4.0   ⋅   4.0\n 4.0    4.0    4.0  4.0  4.0   ⋅","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"For a directed graph, each edge can have two weights, one from src to dst, the other from dst to src.     ","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"Note that a_star() doesn't work with weighted graphs yet.","category":"page"},{"location":"basics.html#Spanning-trees","page":"Basic graphs","title":"Spanning trees","text":"","category":"section"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"A spanning tree is a set of edges that connect all the vertices of a graph together, without forming any cycles. There are various functions for finding spanning trees in Graphs.jl, including algorithms by Otakar Borůvka (boruvka_mst()), Joseph Kruskal (kruskal_mst()), and Robert Prim (prim_mst()). (Immortality can be attained by inventing a new graph-spanning algorithm.)","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"When used on a weighted graph, these functions find the minimum possible tree - the tree that scores the lowest when the weights of the edges are added up. (Some of these functions can also find the highest-scoring trees.)","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"@drawsvg begin\nbackground(\"grey10\")\n\ng = SimpleWeightedGraph(smallgraph(:octahedral))\n\nfor e in edges(g)\n    add_edge!(g, src(e), dst(e), rand(1:10))\nend\nadd_edge!(g, 1, 4, 200)\n\nsethue(\"grey50\")\ndrawgraph(g, layout=spring, vertexshapesizes = 20, edgestrokeweights = 3,\n    edgelabels = (k, src, dest, f, t) ->\n    (sethue(\"cyan\"); label(string(get_weight(g, src, dest)), :nw, midpoint(f, t))))\n\nmst, weights = boruvka_mst(g)\nsethue(\"gold\")\ndrawgraph(g, vertexshapes = :none, layout=spring, edgelist = mst, edgestrokeweights = 15)\n\nmst = kruskal_mst(g)\nsethue(\"green\")\ndrawgraph(g, layout=spring, vertexshapes = :none, edgelist = mst, edgestrokeweights = 10)\n\nmst = prim_mst(g)\nsethue(\"red\")\ndrawgraph(g, layout=spring, vertexshapes = :none, edgelist = mst, edgestrokeweights = 3)\n\nsethue(\"black\")\ndrawgraph(g, layout=spring, vertexlabels = 1:nv(g), edgelines=:none)\n\nend 600 400","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"Notice how all the spanning trees found have avoided the edge joining 1 and 4, which has been given a weight of 200.0.","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"Next, here's boruka_mst() looking for the maximum spanning tree; Edge(1 => 4) is always included everytime the function runs.","category":"page"},{"location":"basics.html","page":"Basic graphs","title":"Basic graphs","text":"@drawsvg begin\nbackground(\"grey10\")\n\ng = SimpleWeightedGraph(smallgraph(:octahedral))\n\nfor e in edges(g)\n    add_edge!(g, src(e), dst(e), rand(1:10))\nend\nadd_edge!(g, 1, 4, 200)\n\nsethue(\"grey50\")\ndrawgraph(g, layout=spring,\n    vertexshapesizes = 20,\n    edgestrokeweights = 3,\n    edgelabels = (k, src, dest, f, t) ->\n        begin\n            sethue(\"orange\")\n            label(string(get_weight(g, src, dest)), :nw, midpoint(f, t))\n        end)\n\nmst, weights = boruvka_mst(g, minimize=false)\nsethue(\"gold\")\ndrawgraph(g, layout=spring,\n        vertexshapes = :none,\n        edgelist = mst,\n        edgestrokeweights = 12)\n\ndrawgraph(g, layout=spring,\n    vertexlabels = 1:nv(g),\n    vertexshapes = :circle,\n    vertexshapesizes = 7.5,\n    edgegaps=0,\n    edgelines=:none)\n\nend 600 400","category":"page"},{"location":"reference/api.html","page":"Function reference","title":"Function reference","text":"Modules = [Karnak]\nOrder   = [:macro, :function, :type, :constant, ]","category":"page"},{"location":"reference/api.html#Karnak.drawgraph-Tuple{AbstractGraph}","page":"Function reference","title":"Karnak.drawgraph","text":"Draw a graph g using coordinates in layout to fit in a Luxor boundingbox.\n\nKeyword arguments\n\nboundingbox::BoundingBox        graph fits inside this BB\nlayout                          Point[] or function\nmargin                          default 20\n\nvertexfunction(vtx, coords) -> _\nedgefunction(edgenumber, from, to, edgesrc, edgedest) -> _\n\nvertexlabels   f                edgelabels  f\nvertexshapes   f                edgelines    f\nvertexshapesizes                edgelist\nvertexshaperotations            edgecurvature\nvertexstrokecolors f            edgestrokecolors   f\nvertexstrokeweights             edgestrokeweights\nvertexfillcolors f              edgedashpatterns\nvertexlabeltextcolors           edgegaps\nvertexlabelfontsizes            edgelabelrotations\nvertexlabelfontfaces            edgelabelcolors\nvertexlabelrotations\nvertexlabeloffsetangles\nvertexlabeloffsetdistances\n\nlayout\n\nthe layout method or coordinates to be used. Examples:\n\nlayout = squaregrid\n\nlayout = shell\n\nlayout = vcat(\n\tbetween.(O + (-W/2, H), O + (W/2, H), range(0, 1, length=N)),\n\tbetween.(O + (-W/2, -H), O + (W/2, -H), range(0, 1, length=N)))\n\nlayout = stress\n\nlayout = (g) -> spectral(adjacency_matrix(g), dim=2)\n\nlayout = shell ∘ adjacency_matrix\n\nlayout = (g) -> sfdp(g, Ptype=Float64, dim=2, tol=0.05, C=0.4, K=2)\n\nlayout = Shell(nlist=[6:10,])\n\nlayout = squaregrid\n\nRefer to the NetworkLayout.jl documentation for more.\n\nExtended help\n\nFunctions to control every aspect of vertex and edge:\n\nvertexfunction(vertex, coordinates) ->\n\nA function vertexfunction(vertex, coordinates) that completely specifies the appearance of every vertex. None of the other vertex- keyword arguments will be used. Example:\n\nvertexfunction = (v, c) -> ngon(c[v], 30, 6, 0, :fill)\n\nedgefunction(edgenumber, from, to, edgesrc, edgedest) ->\n\na function edgefunction(edgenumber, from, to, edgesrc, edgedest) that completely specifies the appearance of every vertex. None of the other edge- keyword arguments are used.\n\nVertex options\n\nvertexfillcolors:  Array | Colorant | :none | Function (vtx) -> the colors for vertex\n\nvertexlabels: Array | Range \" string \"|:none | Function (vtx) ->\n\nThe text labels for each vertex. Vertex labels are not drawn by default.\n\nvertexstrokecolors(vertex) -> vertexstrokecolors(vertex) ->\n\nvertexshapes : Array | Range | :circle | :square | :none | Function (vtx) ->\n\nUse shape for vertex. vtx is vertex number, using current vertex rotation (vertextshaperotations) The function can override rotations and colors.\n\nvertexshapesizes: Array | Range | Real\n\nThe size of each vertex shape for :circle :square...\n\nvertexshaperotations: Array | Range | Real\n\nRotation of shape.\n\nvertexstrokecolors: Array | Colorant | :none | Function (vtx) -> colorant\n\nvertexstrokeweights: Array | Range | :none\n\nvertexfillcolors: Array | Colorant | :none | Function (vtx) -> colorant\n\nvertexlabeltextcolors\n\nvertexlabelfontsizes\n\nvertexlabelfontfaces\n\nvertexlabelrotations\n\nvertexlabeloffsetangles\n\nvertexlabeldistances\n\nEdge options\n\nedgelist: Array | Edge iterator\n\nlist of Edges to be drawn. Takes priority over edgelines.\n\nedgelines: Array | Range | Int| :none | Function (from, to) ->\n\nEdge numbers to be drawn.\n\nedgelabels: Array  | Range | Dict | Function (edgenumber, edgesrc, edgedest, from::Point, to::Point) ->\n\nedgecurvature=0.0\n\nedgestrokecolors: Array | Colorant | Function (n, from, to, s, d)` -> colorant\n\nColors of edges. Function can be edgestrokecolors = (n, from, to, s, d) -> HSB(rescale(n, 1, ne(g), 0, 360), 0.9, 0.8))\n\nedgestrokeweights\n\nedgedashpatterns: Array of Arrays | Array\n\nThe dash pattern or an array of dash patterns for the edge lines. Dash patterns might be eg [[10, 30], [1]]. Numbers alternate between lines and spaces.\n\nedgegaps:\n\ngaps from vertex center to arrow tip\n\nedgelabelcolors\n\nthe colors of the label text\n\nedgelabelrotations\n\nthe rotation of the label text\n\nedgelabelfontsizes\n\nedgelabelfontfaces\n\n\n\n\n\n","category":"method"},{"location":"reference/functionindex.html#Index","page":"Alphabetical function list","title":"Index","text":"","category":"section"},{"location":"reference/functionindex.html","page":"Alphabetical function list","title":"Alphabetical function list","text":"","category":"page"},{"location":"index.html#Introduction-to-Karnak","page":"Introduction to Karnak","title":"Introduction to Karnak","text":"","category":"section"},{"location":"index.html","page":"Introduction to Karnak","title":"Introduction to Karnak","text":"(Image: karnak splash image)","category":"page"},{"location":"index.html","page":"Introduction to Karnak","title":"Introduction to Karnak","text":"Karnak.jl is a small extension for the Luxor.jl package to help with constructing graph-style drawings.","category":"page"},{"location":"index.html","page":"Introduction to Karnak","title":"Introduction to Karnak","text":"Karnak relies on Graphs.jl for graph construction, and on NetworkLayout.jl for graph layout.","category":"page"},{"location":"index.html","page":"Introduction to Karnak","title":"Introduction to Karnak","text":"The focus in Karnak, unlike other graph visualization packages, is on decorative and aesthetic uses, for use in design, generative art, social media previews, NFTs, and other mission-critical items.","category":"page"},{"location":"index.html","page":"Introduction to Karnak","title":"Introduction to Karnak","text":"warning: Warning\nFor mathematical and scientific visualizations, use one of the following Julia packages, rather than this one.TikzGraphs.jl: backend: Tikz/LaTeX\nGraphPlot.jl: backend: Compose.jl\nSGtSNEpi.jl: backend: Makie.jl\nGraphRecipes.jl: backend: Plots.jl\nGraphMakie.jl: backend: Makie.jl","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"using Karnak, Luxor, Graphs, NetworkLayout, Colors, SimpleWeightedGraphs","category":"page"},{"location":"syntax.html#Syntax","page":"Kwarg madness","title":"Syntax","text":"","category":"section"},{"location":"syntax.html#Overview","page":"Kwarg madness","title":"Overview","text":"","category":"section"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"Karnak's function for drawing graphs is drawgraph(). This takes a single argument, a Graph, and tries to place it on the current Luxor drawing. It uses the current color, scale, and rotation, marking the vertices of the graph with circles.","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"@drawsvg begin\nbackground(\"grey10\")\nsethue(\"darkcyan\")\ng = complete_graph(10)\ndrawgraph(g)\nend 600 300","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"To control the appearance of the graph, you supply values to the keyword arguments. Most keyword arguments accepts vectors, ranges, and scalar values, and a few accept functions as well.","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"Here's a contrived (and consequently hideously ugly) example of the type of syntax you can use:","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"@drawsvg begin\nbackground(\"grey10\")\nsethue(\"purple\")\ng = smallgraph(:karate)\ndrawgraph(g, layout=stress,\n    vertexshapes = [:square, :circle],\n    vertexfillcolors = (v) -> v ∈ (1, 3, 6) ? colorant\"red\" : colorant\"grey40\",\n    vertexstrokecolors = colorant\"orange\",\n    vertexstrokeweights = range(0.5, 4, length=nv(g)),\n    vertexshapesizes = 2 .* [Graphs.outdegree(g, v) for v in Graphs.vertices(g)],\n    vertexlabelfontsizes = 2 .* [Graphs.outdegree(g, v) for v in Graphs.vertices(g)],\n    vertexlabels = 1:nv(g),\n    vertexlabelrotations = π/8,\n    vertexlabeltextcolors = distinguishable_colors(10)\n)\nend 600 300","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"Here, the outdegree for each vertex (the number of edges leaving it) is used to control the size of the vertices and the font sizes too. vertexshapes flip-flops between squares and circles for each vertex shape, but the size of the shape is determined by a vertexshapesizes function, which receives a Vector of sizes, the outdegree values for each vertex. The font sizes of the labels are also set this way. A vertexfillcolors function lets you determine the shape's fill color for specific vertices, whereas the stroke color is always orange, with stroke weights gradually increasing. The colors of the labels are set by the Colors.distinguishable_colors() function passed to vertexlabeltextcolors. And all the labels are rotated, for no particularly good reason.","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"Usually, if a vector runs out before the vertices and edges have been drawn, some mod1 magic means the values repeat from the beginning again.","category":"page"},{"location":"syntax.html#The-BoundingBox","page":"Kwarg madness","title":"The BoundingBox","text":"","category":"section"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"The graphics for the graph are placed to fit inside the current BoundingBox (ie the drawing), after allowing for the margin (the default is 30). You can pass a different BoundingBox to the boundingbox keyword argument.","category":"page"},{"location":"syntax.html#Layout-algorithms","page":"Kwarg madness","title":"Layout algorithms","text":"","category":"section"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"The only clever part of this package is provided by NetworkLayout.jl), which is where you should look for information about the various algorithms that determine where vertices are positioned.","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"Here are some formulations which work:","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"layout = squaregrid\n\nlayout = shell\n\nlayout = stress\n\nlayout = spectral\n\nlayout = (g) -> spectral(adjacency_matrix(g), dim=2)\n\nlayout = shell ∘ adjacency_matrix\n\nlayout = (g) -> sfdp(g, Ptype=Float64, dim=2, tol=0.05, C=0.4, K=2)\n\nlayout = Shell(nlist=[6:10,])","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"Alternatively, you can pass a vector of Luxor Points to the layout keyword argument. Vertices will be placed on these points, rather than at points suggested by the NetworkLayout functions.","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"For example, in this next drawing, the two sets of points for a bipartite graph are generated beforehand.","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"@drawsvg begin\nbackground(\"grey10\")\nN = 12; H = 250; W = 550\ng = complete_bipartite_graph(N, N)\npts = vcat(\n    between.(O + (-W/2, -H/2),  O + (-W/2, H/2),  range(0, 1, length=N)), # left set\n    between.(O + (W/2, H/2),   O + (W/2, -H/2), range(0, 1, length=N)))   # right set\ncircle.(pts, 1, :fill)\ndrawgraph(g, vertexlabels = 1:nv(g), layout = pts,\n    edgestrokeweights = 0.5,\n    edgestrokecolors = (n, f, t, s, d) -> HSB(rescale(n, 1, ne(g), 0, 360), 0.6, 0.9))\nend 600 300","category":"page"},{"location":"syntax.html#The-vertexfunction-and-edgefunction-arguments","page":"Kwarg madness","title":"The vertexfunction and edgefunction arguments","text":"","category":"section"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"The two keyword arguments vertexfunction and edgefunction allow you to pass control over the drawing process completely to two functions, which can be anonymous functions.","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"vertexfunction = my_vertexfunction(vertex, coordinates)\nedgefunction = my_edgefunction(edgenumber, from, to, edgesrc, edgedest)","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"These allow you to place graphics at coordinates[vertex], and to draw edges from from to to, using any available tools for drawing.","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"In the following picture, the vertex positions were passed to a function that placed clipped PNG images on the drawing (using Luxor.readpng() and Luxor.placeimage()), and the edges were drawn using sine curves. Refer to the Luxor documentation for more than you could possibly want to know about putting colored things on drawings.","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"(Image: image vertices)","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"It's also possible to draw graphs recursively if you use vertexfunction.","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"g = star_graph(8)\n\nfunction rgraph(g, l=1)\n    if l > 3\n        return\n    else\n    drawgraph(g,\n        layout = stress,\n        vertexfunction = (v, c) -> begin\n            @layer begin\n                sethue(HSB(rescale(v, 1, 8, 0, 360), .7, .8))\n                translate(c[v])\n                circle(c[v], 5, :fill)\n                rgraph(g, l + 1)\n            end\n        end,\n        boundingbox = BoundingBox()/3)\n    end\nend\n\n@drawsvg begin\n    background(\"grey10\")\n    rgraph(g)\nend 800 600","category":"page"},{"location":"syntax.html#Vertex-labels-and-shapes","page":"Kwarg madness","title":"Vertex labels and shapes","text":"","category":"section"},{"location":"syntax.html#The-vertexlabels-argument","page":"Kwarg madness","title":"The vertexlabels argument","text":"","category":"section"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"Use vertexlabels to choose the text to associate with each vertex. Supply a range, array of strings or numbers, or a string.","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"This example draws all vertices, and numbers them from 1 to 6.","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"@drawsvg begin\nbackground(\"grey10\")\ng = smallgraph(:octahedral)\nsethue(\"gold\")\ndrawgraph(g, layout=stress,\n    vertexlabels = 1:nv(g),\n    vertexshapesizes = 10\n    )\nend 600 300","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"You can use a function with vertexlabels to display a vertex; it should return a string to display. Labelling all of them isn't always necessary.","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"@drawsvg begin\nbackground(\"grey10\")\ng = smallgraph(:octahedral)\nsethue(\"purple\")\ndrawgraph(g, layout=stress,\n    vertexlabels = (v) -> v ∈ (1, 4, 6) && string(v),\n    vertexshapesizes = 15,\n    vertexlabelfontsizes = 20,\n    )\nend 600 300","category":"page"},{"location":"syntax.html#vertexshapes-and-vertexshapesizes","page":"Kwarg madness","title":"vertexshapes and vertexshapesizes","text":"","category":"section"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"To determine the shape of the graphic placed at a vertex, you can use these two keyword arguments.","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"Options for vertexshapes are :circle and :square. With just two in a vector, they will be used alternately.","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"@drawsvg begin\nbackground(\"grey10\")\ng = smallgraph(:moebiuskantor)\nsethue(\"gold\")\ndrawgraph(g, layout=shell, vertexshapes = [:square, :circle])\nend 600 300","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"Yes, it's a limited choice. But no worries, because you can pass a function to vertexshapes to draw any shape you like. The single argument is the vertex number; graphics will be centered at the vertex location, ie Luxor's current origin.","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"@drawsvg begin\nbackground(\"grey10\")\ng = smallgraph(:moebiuskantor)\nsethue(\"cyan\")\ndrawgraph(g, layout=shell,\n    vertexshapes = (v) -> star(O, 20, 5, 0.5, 0, :fill))\nend 600 300","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"In the next example, the sizes of the labels and shapes are determined by the degree of each vertex, supplied in a vector.","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"@drawsvg begin\nbackground(\"grey10\")\ng = smallgraph(:karate)\nsethue(\"slateblue\")\ndrawgraph(g, layout=stress,\n    vertexfillcolors = (v) -> v ∈ (1, 3, 6) && colorant\"red\",\n    vertexlabels  = 1:nv(g),\n    vertexlabelfontsizes=[Graphs.outdegree(g, v) for v in Graphs.vertices(g)],\n    vertexshapesizes=[Graphs.outdegree(g, v) for v in Graphs.vertices(g)])\n\nend 600 300","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"To show every other vertex, you could use something like this:","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"@drawsvg begin\nbackground(\"grey10\")\ng = smallgraph(:truncatedcube)\nsethue(\"slateblue\")\ndrawgraph(g, layout=stress,\n    vertexlabels  = [\"1\", \"\"],\n    vertexshapesizes = [10, 0])\nend 600 300","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"One more example with vertexshapes.","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"function whiten(col::Color, f=0.5)\n    hsl = convert(HSL, col)\n    h, s, l = hsl.h, hsl.s, hsl.l\n    return convert(RGB, HSL(h, s, f))\nend\n\nfunction drawball(pos, ballradius, col::Color;\n    \tfromlum=0.2,\n    \ttolum=1.0)\n    gsave()\n    translate(pos)\n    for i in ballradius:-0.25:1\n        sethue(whiten(col, rescale(i, ballradius, 0.5, fromlum, tolum)))\n        offset = rescale(i, ballradius, 0.5, 0, -ballradius/2)\n        circle(O + (offset, offset), i, :fill)\n    end\n    grestore()\nend\n\n@drawsvg begin\nbackground(\"grey10\")\ng = clique_graph(5, 6)\nsethue(\"yellow\")\nsetline(0.2)\ndrawgraph(g,\n    layout = stress,\n    vertexshapes = (v) -> drawball(O, 25, RGB([Luxor.julia_red,Luxor.julia_purple, Luxor.julia_green][rand(1:end)]...))\n)\nend 600 600","category":"page"},{"location":"syntax.html#vertexshaperotations","page":"Kwarg madness","title":"vertexshaperotations","text":"","category":"section"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"@drawsvg begin\nbackground(\"grey10\")\ng = smallgraph(:octahedral)\nsethue(\"slateblue\")\ndrawgraph(g, layout=stress,\n    vertexshapes = :square,\n    vertexshapesizes = 40,\n    vertexshaperotations = range(0, 2π, length = nv(g))\n    )\nend 600 300","category":"page"},{"location":"syntax.html#vertexstrokecolors-and-vertexfillcolors","page":"Kwarg madness","title":"vertexstrokecolors and vertexfillcolors","text":"","category":"section"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"These keywords accept a Colors.jl colorant, an array of them, or a function that generates a color.","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"@drawsvg begin\nbackground(\"grey10\")\ng = smallgraph(:cubical)\nsethue(\"darkorange\")\ndrawgraph(g, layout=stress,\n    vertexshapes = :square,\n    vertexshapesizes =  20,\n    vertexfillcolors = [colorant\"red\", colorant\"blue\"],\n    vertexstrokecolors = [colorant\"blue\", colorant\"red\"])\nend 600 300","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"The function should return a Colorant for a vertex:","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"@drawsvg begin\nbackground(\"grey10\")\ng = smallgraph(:icosahedral)\nsethue(\"darkorange\")\ndrawgraph(g, layout=spring,\n    vertexshapes = :circle,\n    vertexshapesizes =  20,\n    vertexstrokeweights = 5,\n    vertexstrokecolors = (v) -> HSB(rescale(v, 1, nv(g), 360, 0), 1, 1),\n    vertexfillcolors = (v)   -> HSB(rescale(v, 1, nv(g), 0, 359), 1, 1),\n    )\nend 600 300","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"or an array:","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"@drawsvg begin\nbackground(\"grey10\")\nsethue(\"orange\")\ng = grid((15, 15))\ndrawgraph(g,\n    layout = squaregrid,\n    vertexshapesizes = 15,\n    vertexfillcolors = [RGB([Luxor.julia_red, Luxor.julia_green,\n        Luxor.julia_purple][rand(1:end)]...) for i in 1:nv(g)])\nend 600 600","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"Try playing with the following keyword arguments:","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"vertexstrokeweights\nvertexlabeltextcolors\nvertexlabelfontsizes\nvertexlabelfontfaces\nvertexlabelrotations\nvertexlabeloffsetangles\nvertexlabeloffsetdistances","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"Being able to specify the font faces for vertex labels is of vital importance ... but it's difficult to demonstrate when the documentation is built on machines in the cloud with unknown typographical resources. But anyway:","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"@drawsvg begin\nbackground(\"grey10\")\ng = smallgraph(:pappus)\nsethue(\"slateblue\")\ndrawgraph(g,\n    vertexlabels = 1:nv(g),\n    vertexshapes = 0,\n    vertexlabelfontfaces = [\"Times-Roman\", \"Courier\", \"Helvetica-Bold\"],\n    vertexlabelfontsizes = 30)\nend 600 300","category":"page"},{"location":"syntax.html#Edge-options","page":"Kwarg madness","title":"Edge options","text":"","category":"section"},{"location":"syntax.html#edgefunction","page":"Kwarg madness","title":"edgefunction","text":"","category":"section"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"As with vertexfunction, the edgefunction keyword argument allows you to do anything you like when the edges are drawn, and overrides all other keyword arguments. Here, the calculated coordinates of the graph and a path between two vertices are extracted into vectors for later treatment.","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"@drawsvg begin\nbackground(\"black\")\nsethue(\"white\")\ng = clique_graph(16, 4)\n\nA = Point[]\nB = Point[]\n\ndrawgraph(g, layout=stress,\n    edgefunction = (edgenumber, from, to, edgesrc, edgedest) -> begin\n        push!(A, from),\n        push!(A, to)\n        end,\n    vertexshapes = :none,\n    )\n\nroute = a_star(g, 6, 29)\n\ndrawgraph(g, layout=stress,\n    edgelist = route,\n    vertexshapes = :none,\n    edgefunction = (edgenumber, from, to, edgesrc, edgedest) -> begin\n        push!(B, from),\n        push!(B, to)\n        end)\n\n# Luxor takes over:\nsetlinejoin(\"bevel\")\nsetline(0.25)\n\nsethue(\"grey60\")\n@layer begin\n    poly(A, :stroke)\nend\n\nsethue(\"gold\")\nsetline(4)\n@layer begin\n    poly(B, :stroke)\nend\ncircle.(B[[begin, end]], 5, :fill)\nend 600 400","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"note: Note\nThis keyword overrides the other edge- keywords.","category":"page"},{"location":"syntax.html#Edge-labels","page":"Kwarg madness","title":"Edge labels","text":"","category":"section"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"Use edgelabels, edgelabelcolors, edgelabelrotations, etc. to control the appearance of the labels alongside edges. Here, the edgelabels keyword argument accepts a function with five, yes five, arguments: edge number, source, destination, from point, and to point, and is able to annotate each edge with its length in this representation:","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"@drawsvg begin\nbackground(\"grey10\")\ng = smallgraph(:dodecahedral)\ng = complete_graph(5)\nfontsize(20)\ndrawgraph(g, layout=stress,\n    vertexshapes = :none,\n    edgestrokecolors = colorant\"orange\",\n    edgelabels = (k, src, dest, f, t) -> begin\n        @layer begin\n            sethue(\"white\")\n            θ = slope(f, t)\n            text(string(round(distance(f, t), digits=1)),\n                midpoint(f, t),\n                angle=θ,\n                halign=:center)\n        end\n    end)\nend 600 500","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"edgelabels can also be a dictionary, where the keys are tuples, (src, dst), and the values are the text labels.","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"g = complete_graph(5)\nedgelabeldict = Dict()\nn = nv(g)\nfor i in 1:n\n    for j in 1:n\n        edgelabeldict[(i, j)] = \"($i, $j)\"\n    end\nend\n\n@drawsvg begin\n    background(\"grey10\")\n    drawgraph(g, layout=stress,\n        vertexshapes = :circle,\n        vertexlabels = 1:n,\n        edgestrokecolors = colorant\"orange\",\n        edgelabelcolors = colorant\"white\",\n        edgelabels = edgelabeldict)\nend 600 350","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"The more code you're prepared to write, the more elaborate your labels can be:","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"sources      = [1,2,1]\ndestinations = [2,3,3]\nweights      = [0.5, 0.8, 2.0]\ng = SimpleWeightedGraph(sources, destinations, weights)\n@drawsvg begin\nbackground(\"grey10\")\nsethue(\"gold\")\ndrawgraph(g,\n    vertexlabels = 1:nv(g),\n    vertexshapesizes = 20,\n    vertexlabelfontsizes = 30,\n    edgecurvature = 10,\n    edgegaps = 25,\n    edgelabels = (edgenumber, edgesrc, edgedest, from, to) -> begin\n        @layer begin\n            sethue(\"black\")\n            box(midpoint(from, to), 50, 30, :fill)\n        end\n        box(midpoint(from, to), 50, 30, :stroke)\n        fontsize(16)\n        text(string(get_weight(g, edgesrc, edgedest)),\n            midpoint(from, to),\n            halign=:center,\n            valign=:middle)\n    end)\nend 600 300","category":"page"},{"location":"syntax.html#edgelist","page":"Kwarg madness","title":"edgelist","text":"","category":"section"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"This example draws the graph more than once; once with all the edges, and once with only the edges in edgelist, where edgelist is the path from vertex 15 to vertex 17, drawn in a pale translucent yellow. The path is marked with X marks the spot cyan-colored shapes.","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"@drawsvg begin\n    background(\"grey10\")\n    g = smallgraph(:karate)\n    sethue(\"slateblue\")\n    drawgraph(g, layout = stress,\n    vertexlabels = 1:nv(g),\n    vertexshapes = :circle,\n    vertexshapesizes = 10,\n    vertexlabelfontsizes = 10)\n    astar = a_star(g, 15, 17)\n    drawgraph(g,\n    layout=stress,\n     \tvertexshapes = :none,\n    edgelist = astar,\n    edgestrokecolors=RGBA(1, 1, 0, 0.5),\n    edgestrokeweights=10)\n    drawgraph(g,\n    layout=stress,\n    edgelines=0,\n    vertexshapes = (v) -> v ∈ src.(astar) && polycross(O, 20, 4, 0.5, π/4, :fill),\n     \tvertexfillcolors = (v) -> v ∈ src.(astar) && colorant\"cyan\"\n    )\nend 600 600","category":"page"},{"location":"syntax.html#edgecurvature-and-edgecaps","page":"Kwarg madness","title":"edgecurvature and edgecaps","text":"","category":"section"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"edgecurvature determines the curvature of the edges, and edgegaps sets the distance between the tip of the arrowhead and the vertex position.","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"g = grid((3, 3))\n\n# add some self-loops\nfor e in edges(g)\n    add_edge!(g, src(e), src(e))\n    add_edge!(g, dst(e), dst(e))\nend\n\n@drawsvg begin\n    background(\"grey10\")\n    sethue(\"white\")\n    for c in 1:10\n        drawgraph(g,\n            margin=70,\n            vertexshapes = :none,\n            edgegaps = 5c,\n            edgecurvature = 5c,\n            edgestrokecolors = HSB(36c, .8, .8),\n            edgestrokeweights = 1,\n            layout=squaregrid)\n    end\nend 600 500","category":"page"},{"location":"syntax.html#edgestrokecolors-and-edgestrokeweights","page":"Kwarg madness","title":"edgestrokecolors and edgestrokeweights","text":"","category":"section"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"g = barbell_graph(3, 3)\n@drawsvg begin\n    background(\"grey10\")\n    fontsize(30)\n    sethue(\"white\")\n    drawgraph(g,\n        layout=stress,\n        edgelabels = 1:ne(g),\n        edgecurvature = 10,\n        edgestrokeweights = 2 * (1:ne(g)),\n        edgelabelcolors = colorant\"white\",\n        edgestrokecolors= (n, from, to, edgesrc, edgedest) -> HSB(rescale(n, 1, ne(g), 0, 359), .8, .8))\nend 600 500","category":"page"},{"location":"syntax.html#edgedashpatterns","page":"Kwarg madness","title":"edgedashpatterns","text":"","category":"section"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"Line dashes work the same as in Luxor.jl, numbers in an array. If you want to alternate between dash patterns, supply an array of patterns.","category":"page"},{"location":"syntax.html","page":"Kwarg madness","title":"Kwarg madness","text":"g = grid((5, 5))\n@drawsvg begin\n    background(\"grey10\")\n    sethue(\"white\")\n    drawgraph(g,\n        layout=squaregrid,\n        edgestrokeweights = 5,\n        edgelabels = (edgenumber, edgesrc, edgedest, from::Point, to::Point) ->\n            begin\n                labeltext = [\"a\", \"b\", \"c\"][mod1(edgenumber, end)]\n                label(labeltext, :se, midpoint(from, to), offset=5)\n            end,\n        edgedashpatterns = [[20, 10, 1, 10], [20, 10], [0.5, 10]],\n        edgelabelfontsizes = 20,\n        vertexshapesizes = 2,\n        edgestrokecolors=(edgenumber, from, to, src, dst) ->\n            HSB(rescale(edgenumber, 1, ne(g), 0, 359), .8, .8)\n          )\nend 600 400","category":"page"}]
}
