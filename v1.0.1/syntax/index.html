<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Syntax · Karnak</title><meta name="title" content="Syntax · Karnak"/><meta property="og:title" content="Syntax · Karnak"/><meta property="twitter:title" content="Syntax · Karnak"/><meta name="description" content="Documentation for Karnak."/><meta property="og:description" content="Documentation for Karnak."/><meta property="twitter:description" content="Documentation for Karnak."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/karnak-docs.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Karnak logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Karnak</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction to Karnak</a></li><li><a class="tocitem" href="../basics/">Basic graphs</a></li><li class="is-active"><a class="tocitem" href>Syntax</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Summary-of-keywords"><span>Summary of keywords</span></a></li><li><a class="tocitem" href="#The-BoundingBox"><span>The BoundingBox</span></a></li><li><a class="tocitem" href="#Layout-algorithms"><span>Layout algorithms</span></a></li><li><a class="tocitem" href="#The-vertexfunction-and-edgefunction-arguments"><span>The <code>vertexfunction</code> and <code>edgefunction</code> arguments</span></a></li><li><a class="tocitem" href="#Functions-as-keyword-arguments"><span>Functions as keyword arguments</span></a></li><li><a class="tocitem" href="#Vertex-labels-and-shapes"><span>Vertex labels and shapes</span></a></li><li><a class="tocitem" href="#Edge-options"><span>Edge options</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../reference/functionindex/">Alphabetical function list</a></li><li><a class="tocitem" href="../reference/api/">Function reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Syntax</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Syntax</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/cormullion/Karnak.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/cormullion/Karnak.jl/blob/master/docs/src/syntax.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Syntax"><a class="docs-heading-anchor" href="#Syntax">Syntax</a><a id="Syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Syntax" title="Permalink"></a></h1><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>Karnak&#39;s function for drawing graphs is <code>drawgraph()</code>. This takes a single argument, a <code>Graph</code>, and tries to place representative graphics on the current Luxor drawing.</p><p>The default display for graphs is:</p><ul><li><p>current Luxor origin, scale and rotation</p></li><li><p>current Luxor color for edges</p></li><li><p>circles for all vertex shapes</p></li><li><p>no vertex labels</p></li><li><p>all edges drawn</p></li></ul><pre><code class="language- hljs">@drawsvg begin
    background(&quot;grey10&quot;)
    sethue(&quot;darkcyan&quot;)
    g = complete_graph(10)
    drawgraph(g)
end 600 300</code></pre><p>To control the appearance of the graph, you supply values to the various keyword arguments. Apart from the general keywords <code>BoundingBox</code>, <code>layout</code>, and <code>margin</code>, the keywords can be grouped into two categories:</p><p><img src="../assets/figures/drawgraphkeywords.svg" alt="two groups of keyword"/></p><p>Most of these keyword arguments accept vectors, ranges, and scalar values, and some accept functions as well.</p><p>Here&#39;s a contrived (and consequently hideously ugly) example of the type of syntax available:</p><pre><code class="language- hljs">@drawsvg begin
background(&quot;grey10&quot;)
sethue(&quot;purple&quot;)
g = smallgraph(:karate)
drawgraph(g, layout=stress,
    vertexshapes = [:square, :circle],
    vertexfillcolors = (v) -&gt; v ∈ (1, 3, 6) ? colorant&quot;red&quot; : colorant&quot;grey40&quot;,
    vertexstrokecolors = colorant&quot;orange&quot;,
    vertexstrokeweights = range(0.5, 4, length=nv(g)),
    vertexshapesizes = 2 .* [Graphs.outdegree(g, v) for v in Graphs.vertices(g)],
    vertexlabelfontsizes = 2 .* [Graphs.outdegree(g, v) for v in Graphs.vertices(g)],
    vertexlabels = 1:nv(g),
    vertexlabelrotations = π/8,
    vertexlabeltextcolors = distinguishable_colors(10)
)
end 600 300</code></pre><p>Here, the <strong>outdegree</strong> for each vertex (the number of edges leaving it) is used to control the size of the vertices and the font sizes too. <code>vertexshapes</code> flip-flops between squares and circles for each vertex shape, but the size of the shape is determined by a <code>vertexshapesizes</code> function, which receives a Vector of sizes, the outdegree values for each vertex. The font sizes of the labels are also set this way. A <code>vertexfillcolors</code> function lets you determine the shape&#39;s fill color for specific vertices, whereas the stroke color is always orange, with stroke weights gradually increasing. The colors of the labels are set by the <code>Colors.distinguishable_colors()</code> function passed to <code>vertexlabeltextcolors</code>. And all the labels are rotated, for no particularly good reason.</p><p>Usually, if a vector runs out before the vertices and edges have been drawn, some <code>mod1</code> magic means the values repeat from the beginning again.</p><p>Use <code>drawgraph()</code> more than once, if needed, to build up the graph in layers. Remember to use the same layout algorithm.</p><h2 id="Summary-of-keywords"><a class="docs-heading-anchor" href="#Summary-of-keywords">Summary of keywords</a><a id="Summary-of-keywords-1"></a><a class="docs-heading-anchor-permalink" href="#Summary-of-keywords" title="Permalink"></a></h2><table><tr><th style="text-align: right"></th><th style="text-align: left"></th><th style="text-align: left"></th></tr><tr><td style="text-align: right">boundingbox</td><td style="text-align: left">BoundingBox</td><td style="text-align: left">drawing will fit inside this bounding box</td></tr><tr><td style="text-align: right">margin</td><td style="text-align: left">Number</td><td style="text-align: left">margin in points/pixels</td></tr><tr><td style="text-align: right">layout</td><td style="text-align: left">Vector{Point}</td><td style="text-align: left">list of coordinates of each vertex</td></tr><tr><td style="text-align: right"></td><td style="text-align: left">function from NetworkLayout.jl</td><td style="text-align: left">squaregrid, shell, stress, etc</td></tr><tr><td style="text-align: right"></td><td style="text-align: left">f(g::Graph)</td><td style="text-align: left">(g) -&gt; spectral(adjacency_matrix(g), dim=2)</td></tr><tr><td style="text-align: right">edgefunction</td><td style="text-align: left">f(edgenumber::Int, edgesrc::Int, edgedest::Int, from::Point, to::Point)</td><td style="text-align: left">function that completely specifies the appearance of every edge. If present, none of the other edge- keyword arguments are used.</td></tr><tr><td style="text-align: right">vertexfunction</td><td style="text-align: left">f(vtx::Int, coordinates::Vector{Point})</td><td style="text-align: left">function that completely specifies the appearance of every vertex. If present, None of the other vertex- keyword arguments will be used.</td></tr><tr><td style="text-align: right">edgecurvature</td><td style="text-align: left">Float64</td><td style="text-align: left">curviness of edge arrows</td></tr><tr><td style="text-align: right">edgedashpatterns</td><td style="text-align: left">Vector{Vector}[number]</td><td style="text-align: left">vector of dash patterns</td></tr><tr><td style="text-align: right"></td><td style="text-align: left">Vector{Number}</td><td style="text-align: left">a dash pattern</td></tr><tr><td style="text-align: right">edgegaps</td><td style="text-align: left">Vector</td><td style="text-align: left">gaps from each vertex center to arrow tip</td></tr><tr><td style="text-align: right"></td><td style="text-align: left">Range</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">Real</td><td style="text-align: left">gaps from every vertex center to arrow tip</td></tr><tr><td style="text-align: right">edgelabelcolors</td><td style="text-align: left">Vector{Colorant}</td><td style="text-align: left">colors of each vertex&#39;s label text</td></tr><tr><td style="text-align: right"></td><td style="text-align: left">Colorant</td><td style="text-align: left">color of all vertex labels</td></tr><tr><td style="text-align: right">edgelabelfontfaces</td><td style="text-align: left">Vector{Strings}[edgenumber]</td><td style="text-align: left">font face for each edge</td></tr><tr><td style="text-align: right"></td><td style="text-align: left">String</td><td style="text-align: left">font face for every edge</td></tr><tr><td style="text-align: right"></td><td style="text-align: left">:none</td><td style="text-align: left"></td></tr><tr><td style="text-align: right">edgelabelfontsizes</td><td style="text-align: left">Vector{Number}</td><td style="text-align: left">the font size of each edge label</td></tr><tr><td style="text-align: right"></td><td style="text-align: left">Number</td><td style="text-align: left">the font size of every edge label</td></tr><tr><td style="text-align: right">edgelabelrotations</td><td style="text-align: left">Vector{angles}</td><td style="text-align: left">rotation of each label</td></tr><tr><td style="text-align: right"></td><td style="text-align: left">angle::Float64</td><td style="text-align: left">rotation of every label</td></tr><tr><td style="text-align: right"></td><td style="text-align: left">f(edgenumber, edges, edgedest, from, to)</td><td style="text-align: left">function returns angle for this edge</td></tr><tr><td style="text-align: right">edgelabels</td><td style="text-align: left">Vector</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">range</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">Dict{Int, Int}</td><td style="text-align: left">(src, dst) =&gt; &quot;labeltext&quot;</td></tr><tr><td style="text-align: right"></td><td style="text-align: left">f(edgenumber, edgesrc, edgedest, from::Point, to::Point)</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">:none</td><td style="text-align: left"></td></tr><tr><td style="text-align: right">edgelines</td><td style="text-align: left">Vector{Int}</td><td style="text-align: left">numbers of edges to be drawn</td></tr><tr><td style="text-align: right"></td><td style="text-align: left">range</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">Int</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">f(edgenumber, edgesrc, edgedest, from::Point, to::Point)</td><td style="text-align: left"></td></tr><tr><td style="text-align: right">edgelist</td><td style="text-align: left">Graphs.EdgeIterator</td><td style="text-align: left">the edges to be drawn - takes prioity over edgelines</td></tr><tr><td style="text-align: right">edgestrokecolors</td><td style="text-align: left">Vector{Colorant}[edge::Int]</td><td style="text-align: left">colors for edges</td></tr><tr><td style="text-align: right"></td><td style="text-align: left">Colorant</td><td style="text-align: left">color for every edge</td></tr><tr><td style="text-align: right"></td><td style="text-align: left">f(edgenumber, edgesrc, edgedest, from::Point, to::Point)</td><td style="text-align: left">function to set color for this edge</td></tr><tr><td style="text-align: right">edgestrokeweights</td><td style="text-align: left">Vector{Number}[vtx]</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">range</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">Real</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">f(edgenumber, edgesrc, edgedest, from::Point, to::Point)</td><td style="text-align: left">function that returns a value for line width</td></tr><tr><td style="text-align: right">vertexfillcolors</td><td style="text-align: left">Vector{Colorant}</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">Colorant</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">:none</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">f(vtx::Int)</td><td style="text-align: left"></td></tr><tr><td style="text-align: right">vertexlabelfontfaces</td><td style="text-align: left">Vector{Strings}</td><td style="text-align: left">font face for each vertex</td></tr><tr><td style="text-align: right"></td><td style="text-align: left">String</td><td style="text-align: left">font face for every vertex</td></tr><tr><td style="text-align: right">vertexlabelfontsizes</td><td style="text-align: left">Vector</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">range</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">Real</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">:none</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">f(vtx::Int, coords::Point[])</td><td style="text-align: left">function returns the fontsize for this label</td></tr><tr><td style="text-align: right">vertexlabeloffsetangles</td><td style="text-align: left">Vector</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">Range</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">Real</td><td style="text-align: left"></td></tr><tr><td style="text-align: right">vertexlabeloffsetdistances</td><td style="text-align: left">Vector</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">range</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">Real</td><td style="text-align: left"></td></tr><tr><td style="text-align: right">vertexlabelrotations</td><td style="text-align: left">Vector</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">range</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">Real</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">:none</td><td style="text-align: left"></td></tr><tr><td style="text-align: right">vertexlabels</td><td style="text-align: left">Vector{String}</td><td style="text-align: left">cycles</td></tr><tr><td style="text-align: right"></td><td style="text-align: left">String</td><td style="text-align: left">used for all vertices</td></tr><tr><td style="text-align: right"></td><td style="text-align: left">range[vtx::Int]</td><td style="text-align: left">string of the number in the range, cycles</td></tr><tr><td style="text-align: right"></td><td style="text-align: left">:none</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">f(vtx::Int)</td><td style="text-align: left">function returns a string for the vertex label</td></tr><tr><td style="text-align: right">vertexlabeltextcolors</td><td style="text-align: left">Vector{Colorant}</td><td style="text-align: left">color for each text label</td></tr><tr><td style="text-align: right"></td><td style="text-align: left">Colorant</td><td style="text-align: left">color of all text labels</td></tr><tr><td style="text-align: right"></td><td style="text-align: left">:none</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">f(vtx::Int)</td><td style="text-align: left">function returning a colorant</td></tr><tr><td style="text-align: right">vertexshaperotations</td><td style="text-align: left">f(vtx::Int)</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">angle::Float64</td><td style="text-align: left"></td></tr><tr><td style="text-align: right">vertexshapes</td><td style="text-align: left">Vector of :circle :square :none</td><td style="text-align: left">shapes of each vertex</td></tr><tr><td style="text-align: right"></td><td style="text-align: left">range[vtx]</td><td style="text-align: left">draw default shape at this vertex</td></tr><tr><td style="text-align: right"></td><td style="text-align: left">:circle :square :none</td><td style="text-align: left">shape of every vertex</td></tr><tr><td style="text-align: right"></td><td style="text-align: left">f(vtx::Int)</td><td style="text-align: left">function draws shape at this vertex (which is Point(0, 0))</td></tr><tr><td style="text-align: right">vertexshapesizes</td><td style="text-align: left">Vector{Real}</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">range</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">Real</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">:none</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">f(vtx::Int)</td><td style="text-align: left"></td></tr><tr><td style="text-align: right">vertexstrokecolors</td><td style="text-align: left">Vector</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">Colorant</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">:none</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">f(vtx::Int)</td><td style="text-align: left"></td></tr><tr><td style="text-align: right">vertexstrokeweights</td><td style="text-align: left">Vector</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">range</td><td style="text-align: left"></td></tr><tr><td style="text-align: right"></td><td style="text-align: left">:none</td><td style="text-align: left"></td></tr></table><h2 id="The-BoundingBox"><a class="docs-heading-anchor" href="#The-BoundingBox">The BoundingBox</a><a id="The-BoundingBox-1"></a><a class="docs-heading-anchor-permalink" href="#The-BoundingBox" title="Permalink"></a></h2><p>The graphics for the graph are placed to fit inside the current BoundingBox (by default, the drawing), after allowing for the margin (the default is 30). Pass a different BoundingBox to the <code>boundingbox</code> keyword argument to control the graph layout&#39;s size.</p><h2 id="Layout-algorithms"><a class="docs-heading-anchor" href="#Layout-algorithms">Layout algorithms</a><a id="Layout-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Layout-algorithms" title="Permalink"></a></h2><p>The only clever part of this package is provided by <a href="https://juliagraphs.org/NetworkLayout.jl/">NetworkLayout.jl</a>), which is where you should look for information about the various algorithms that determine where vertices are positioned.</p><p>You can choose a layout algorithm, or supply the vertex positions yourself.</p><p>The main layout algorithms available are:</p><ul><li><p>shell</p></li><li><p>spring</p></li><li><p>stress</p></li><li><p>squaregrid</p></li></ul><p>Here are some formulations which work as keywords in <code>drawgraph()</code>:</p><pre><code class="language-julia hljs">layout = squaregrid

layout = shell

layout = stress

layout = spectral

layout = (g) -&gt; spectral(adjacency_matrix(g), dim=2)

layout = shell ∘ adjacency_matrix

layout = (g) -&gt; sfdp(g, Ptype=Float64, dim=2, tol=0.05, C=0.4, K=2)

layout = Shell(nlist=[6:10,])

layout = Stress(iterations = 100, weights = M) # M is matrix of weights

layout = Spring(iterations = 200, initialtemp = 2.5)</code></pre><p>Alternatively, you can pass a vector of points to the <code>layout</code> keyword argument. Vertices will be placed on these points (vertex 1 on point 1, etc...), rather than at points suggested by the NetworkLayout algorithms. For example, in this next drawing, the two sets of points for a bipartite graph are generated beforehand.</p><pre><code class="language- hljs">@drawsvg begin
background(&quot;grey10&quot;)
N = 12; H = 250; W = 550
g = complete_bipartite_graph(N, N)
pts = vcat(
    between.(O + (-W/2, -H/2),  O + (-W/2, H/2),  range(0, 1, length=N)), # left set
    between.(O + (W/2, H/2),   O + (W/2, -H/2), range(0, 1, length=N)))   # right set
circle.(pts, 1, :fill)
drawgraph(g, vertexlabels = 1:nv(g), layout = pts,
    edgestrokeweights = 0.5,
    edgestrokecolors = (n, f, t, s, d) -&gt; HSB(rescale(n, 1, ne(g), 0, 360), 0.6, 0.9))
end 600 300</code></pre><p>The calculated positions are returned by the <code>drawgraph()</code> function.</p><h3 id="Initial-positions-for-the-layout-algorithms"><a class="docs-heading-anchor" href="#Initial-positions-for-the-layout-algorithms">Initial positions for the layout algorithms</a><a id="Initial-positions-for-the-layout-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-positions-for-the-layout-algorithms" title="Permalink"></a></h3><p>Some of the layout algorithms - the Spring and Stress ones, for example -  allow you to pass <em>initial</em> vertex positions to be used by the algorithms as starting points. The algorithm will continually adjust them to make a better result. These initial positions should be supplied as xy pairs, rather than Luxor Points (which NetworkLayout doesn&#39;t know about).</p><p>Here&#39;s an animation showing how the Stress algorithm gradually improves the layout on each iteration. The initial positions are just the &quot;grid locations&quot; of a Luxor Tiler.</p><pre><code class="language-julia hljs">using Karnak, Graphs, NetworkLayout, Colors

function frame(scene, framenumber, G)

    background(&quot;black&quot;)
    initialpositions = [(pt.x, pt.y) for (pt, n) in Tiler(600, 600, 3, 3)]

    sethue(&quot;grey50&quot;)
    circle.(Point.(initialpositions), 3, :fill)

    for i in 1:framenumber
        setopacity(rescale(i, 1, scene.framerange.stop, 0, 0.6))
        drawgraph(G,
            layout=Stress(initialpos=initialpositions, iterations=i),
            vertexfillcolors=(i == framenumber) ? colorant&quot;gold&quot; : :none
        )
    end

end

function main()
    G = smallgraph(:petersen)
    amovie = Movie(600, 600, &quot;layout&quot;)
    animate(amovie,
        Scene(amovie, (s, f) -&gt; frame(s, f, G), 1:60),
        framerate=10, creategif=true)
end

main()</code></pre><p><img src="../assets/figures/stresslayout.gif" alt="animate stress algorithm"/></p><h2 id="The-vertexfunction-and-edgefunction-arguments"><a class="docs-heading-anchor" href="#The-vertexfunction-and-edgefunction-arguments">The <code>vertexfunction</code> and <code>edgefunction</code> arguments</a><a id="The-vertexfunction-and-edgefunction-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#The-vertexfunction-and-edgefunction-arguments" title="Permalink"></a></h2><p>The two keyword arguments <code>vertexfunction</code> and <code>edgefunction</code> allow you to pass control over the drawing process completely to these two functions.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If you define these functions, all the other vertex/edge keywords are ignored.</p></div></div><pre><code class="nohighlight hljs">vertexfunction = my_vertexfunction(vertex, coordinates)
edgefunction = my_edgefunction(edgenumber, edgesrc, edgedest, from::Point, to::Point)</code></pre><p>These allow you to place graphics at <code>coordinates[vertex]</code>, and to draw edges from <code>from</code> to <code>to</code>, using any available tools for drawing.</p><p>In the following picture, the vertex positions were passed to a function that placed clipped PNG images on the drawing (using <code>Luxor.readpng()</code> and <code>Luxor.placeimage()</code>), and the edges were drawn using sine curves. Refer to the Luxor documentation for more about putting colored things on drawings.</p><p><img src="../assets/figures/karnakmap.png" alt="image vertices"/></p><p>It&#39;s also possible, for example, to draw a graph at a vertex point (ie recursive graph drawing) if you use <code>vertexfunction</code>.</p><pre><code class="language- hljs">g = complete_graph(5)

function rgraph(g, l=1)
    if l &gt; 4
        return
    else
        drawgraph(g,
            layout=stress,
            boundingbox=BoundingBox() / 2l,
            vertexfunction=(v, c) -&gt; begin
                @layer begin
                    sethue(HSB(rescale(v, 1, 4, 0, 360), 0.7, 0.8))
                    translate(c[v])
                    #circle(c[v], 5, :fill)
                    rgraph(g, l + 1)
                end
            end,
            )
    end
end

@drawsvg begin
    background(&quot;grey10&quot;)
    sethue(&quot;gold&quot;)
    rgraph(g)
end 800 600</code></pre><h2 id="Functions-as-keyword-arguments"><a class="docs-heading-anchor" href="#Functions-as-keyword-arguments">Functions as keyword arguments</a><a id="Functions-as-keyword-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-as-keyword-arguments" title="Permalink"></a></h2><p>The following keyword arguments accept functions:</p><ul><li><code>edgelabelrotations</code></li><li><code>edgelabels</code></li><li><code>edgelines</code></li><li><code>edgestrokecolors</code></li><li><code>edgestrokeweights</code></li><li><code>vertexfillcolors</code></li><li><code>vertexlabels</code></li><li><code>vertexlabeltextcolors</code></li><li><code>vertexshaperotations</code></li><li><code>vertexshapes</code></li><li><code>vertexshapesizes</code></li><li><code>vertexstrokecolors</code></li><li><code>vertexstrokeweights</code></li></ul><p>The <code>edge-</code> keywords accept functions with arguments <code>(edgenumber, sourcevertex, destinationvertex, frompoint, topoint)</code>. The <code>vertex-</code> keywords accept functions with arguments <code>(vertex)</code>.</p><p>These functions aren&#39;t used if you supply functions to <code>vertexfunction</code> or <code>edgefunction</code>.</p><h2 id="Vertex-labels-and-shapes"><a class="docs-heading-anchor" href="#Vertex-labels-and-shapes">Vertex labels and shapes</a><a id="Vertex-labels-and-shapes-1"></a><a class="docs-heading-anchor-permalink" href="#Vertex-labels-and-shapes" title="Permalink"></a></h2><h3 id="vertexlabels"><a class="docs-heading-anchor" href="#vertexlabels"><code>vertexlabels</code></a><a id="vertexlabels-1"></a><a class="docs-heading-anchor-permalink" href="#vertexlabels" title="Permalink"></a></h3><p>Use <code>vertexlabels</code> to choose the text to associate with each vertex. Supply a range, array of strings or numbers, a single string, or a function.</p><p>This example draws all vertices, and numbers them from 1 to 6.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In Graphs.jl, vertices are always numbered from 1 to <code>n</code>. If you remove a vertex, vertices are effectively re-numbered.</p></div></div><pre><code class="language- hljs">@drawsvg begin
    background(&quot;grey10&quot;)
    g = smallgraph(:octahedral)
    sethue(&quot;gold&quot;)
    drawgraph(g, layout=stress,
        vertexlabels = 1:nv(g),
        vertexshapesizes = 10)
end 600 300</code></pre><p>A function can be passed to <code>vertexlabels</code> to display a vertex; it should accept a single numerical argument, the vertex number, and return a string to display. Labelling all of them isn&#39;t always necessary.</p><pre><code class="language- hljs">@drawsvg begin
background(&quot;grey10&quot;)
g = smallgraph(:octahedral)
sethue(&quot;skyblue&quot;)
drawgraph(g, layout=stress,
    vertexlabels = (v) -&gt; v ∈ (1, 4, 6) &amp;&amp; string(v, &quot;/6&quot;),
    vertexshapesizes = 15,
    vertexlabelfontsizes = 20,
    )
end 600 300</code></pre><h3 id="Using-LaTex-in-labels"><a class="docs-heading-anchor" href="#Using-LaTex-in-labels">Using LaTex in labels</a><a id="Using-LaTex-in-labels-1"></a><a class="docs-heading-anchor-permalink" href="#Using-LaTex-in-labels" title="Permalink"></a></h3><p>If you want to use <span>$\LaTeX$</span> in vertex labels, you can load <a href="https://github.com/Kolaru/MathTeXEngine.jl">MathTeXEngine.jl</a> to parse the <code>LaTeXString</code>s. Make sure the fonts in the MathTexEngine package are also available to the Operating System&#39;s font routines (so <strong>copying</strong> them to your local font folder is probably required).</p><pre><code class="language-julia hljs">using Karnak, Graphs, NetworkLayout, Colors
using MathTeXEngine, LaTeXStrings

g = complete_graph(4)
@svg begin
    background(&quot;grey10&quot;)
    sethue(&quot;cyan&quot;)
    fontsize(40)
    drawgraph(g,
        margin=30,
        vertexlabels = [L&quot;v_%$(x)&quot; for x in 1:nv(g)],
        vertexlabeloffsetdistances = [40, 40, -40, 40],
        vertexlabeltextcolors = colorant&quot;white&quot;
    )
end 600 300</code></pre><p><img src="../assets/figures/latextext.svg" alt="latex tet"/></p><h3 id="vertexshapes-and-vertexshapesizes"><a class="docs-heading-anchor" href="#vertexshapes-and-vertexshapesizes"><code>vertexshapes</code> and <code>vertexshapesizes</code></a><a id="vertexshapes-and-vertexshapesizes-1"></a><a class="docs-heading-anchor-permalink" href="#vertexshapes-and-vertexshapesizes" title="Permalink"></a></h3><p>The default shape for a vertex is a filled circle.</p><p>Options for <code>vertexshapes</code> are <code>:circle</code> and <code>:square</code>. With just two in a vector, they will be used alternately.</p><pre><code class="language- hljs">@drawsvg begin
background(&quot;grey10&quot;)
g = smallgraph(:moebiuskantor)
sethue(&quot;gold&quot;)
drawgraph(g, layout=shell, vertexshapes = [:square, :circle])
end 600 300</code></pre><p><code>vertexshapesizes</code> can set the sizes for the built-in vertex shapes.</p><pre><code class="language- hljs">@drawsvg begin
background(&quot;grey10&quot;)
g = smallgraph(:moebiuskantor)
sethue(&quot;gold&quot;)
drawgraph(g, layout=shell,
    vertexshapes = [:square, :circle],
    vertexshapesizes = [15, 5])
end 600 300</code></pre><pre><code class="language- hljs">@drawsvg begin
background(&quot;grey10&quot;)
g = smallgraph(:moebiuskantor)
sethue(&quot;gold&quot;)
drawgraph(g, layout=shell,
    vertexshapesizes = (v) -&gt; rescale(v, 1, nv(g), 5, 25))
end 600 300</code></pre><p><code>vertexshaperotations</code> can set the rotations.</p><pre><code class="language- hljs">@drawsvg begin
background(&quot;grey10&quot;)
g = smallgraph(:moebiuskantor)
sethue(&quot;gold&quot;)
drawgraph(g, layout=shell,
    vertexshapes = :square,
    vertexshapesizes = [10, 20, 5],
    vertexshaperotations = [π/2, π/3],
    )
end 600 300</code></pre><p>To show every other vertex and label, you could use something like this:</p><pre><code class="language- hljs">@drawsvg begin
background(&quot;grey10&quot;)
g = smallgraph(:truncatedcube)
sethue(&quot;darkturquoise&quot;)
drawgraph(g, layout=stress,
    vertexlabels = [&quot;1&quot;, &quot;&quot;],
    vertexshapesizes = [10, 0])
end 600 300</code></pre><p>When circles and squares don&#39;t cut it, supply a function to <code>vertexshapes</code>. The single argument is the vertex number; any graphics you draw will be centered at the vertex location, Luxor&#39;s current origin, <code>Point(0, 0)</code>.</p><pre><code class="language- hljs">@drawsvg begin
background(&quot;grey10&quot;)
g = smallgraph(:moebiuskantor)
sethue(&quot;hotpink&quot;)
drawgraph(g, layout=shell,
    vertexshapes = (v) -&gt; star(O, 15, v+2, 0.5, 0, :fill))
end 600 300</code></pre><p>Here, the vertex number is hinted at by the number of points on each star.</p><p>In the next example, the sizes of the labels and shapes are determined by the degree of each vertex, supplied in a vector.</p><pre><code class="language- hljs">@drawsvg begin
background(&quot;grey10&quot;)
g = smallgraph(:karate)
sethue(&quot;slateblue&quot;)
drawgraph(g, layout=stress,
    vertexlabels = 1:nv(g),
    vertexlabelfontsizes = [Graphs.outdegree(g, v) for v in Graphs.vertices(g)],
    vertexshapesizes = [Graphs.outdegree(g, v) for v in Graphs.vertices(g)],
    vertexfillcolors = (v) -&gt; v ∈ (1, 3, 6) &amp;&amp; colorant&quot;red&quot;,
    )
end 600 300</code></pre><p>One more example with <code>vertexshapes</code>.</p><pre><code class="language- hljs">function whiten(col::Color, f=0.5)
    hsl = convert(HSL, col)
    h, s, l = hsl.h, hsl.s, hsl.l
    return convert(RGB, HSL(h, s, f))
end

function drawball(pos, ballradius, col::Color;
        fromlum=0.2,
        tolum=1.0)
    gsave()
    translate(pos)
    for i in ballradius:-0.25:1
        sethue(whiten(col, rescale(i, ballradius, 0.5, fromlum, tolum)))
        offset = rescale(i, ballradius, 0.5, 0, -ballradius/2)
        circle(O + (offset, offset), i, :fill)
    end
    grestore()
end

@drawsvg begin
background(&quot;grey10&quot;)
g = clique_graph(5, 6)
sethue(&quot;yellow&quot;)
setline(0.2)
drawgraph(g,
    layout = stress,
    vertexshapes = (v) -&gt; drawball(O, 25, RGB([Luxor.julia_red,Luxor.julia_purple, Luxor.julia_green][rand(1:end)]...))
)
end 600 600</code></pre><h3 id="vertexstrokecolors-and-vertexfillcolors"><a class="docs-heading-anchor" href="#vertexstrokecolors-and-vertexfillcolors"><code>vertexstrokecolors</code> and <code>vertexfillcolors</code></a><a id="vertexstrokecolors-and-vertexfillcolors-1"></a><a class="docs-heading-anchor-permalink" href="#vertexstrokecolors-and-vertexfillcolors" title="Permalink"></a></h3><p>These keywords accept a Colors.jl <code>colorant</code>, an array of them, or a function that generates a color.</p><pre><code class="language- hljs">@drawsvg begin
background(&quot;grey10&quot;)
g = smallgraph(:cubical)
sethue(&quot;darkorange&quot;)
drawgraph(g, layout=stress,
    vertexshapes = :square,
    vertexshapesizes =  20,
    vertexfillcolors = [colorant&quot;red&quot;, colorant&quot;blue&quot;],
    vertexstrokecolors = [colorant&quot;blue&quot;, colorant&quot;red&quot;])
end 600 300</code></pre><p>The function should return a Colorant for a vertex:</p><pre><code class="language- hljs">@drawsvg begin
background(&quot;grey10&quot;)
g = smallgraph(:icosahedral)
sethue(&quot;darkorange&quot;)
drawgraph(g, layout=spring,
    vertexshapes = :circle,
    vertexshapesizes =  20,
    vertexstrokeweights = 5,
    vertexstrokecolors = (v) -&gt; HSB(rescale(v, 1, nv(g), 360, 0), 1, 1),
    vertexfillcolors = (v)   -&gt; HSB(rescale(v, 1, nv(g), 0, 359), 1, 1),
    )
end 600 300</code></pre><p>or an array of colors:</p><pre><code class="language- hljs">@drawsvg begin
background(&quot;grey10&quot;)
sethue(&quot;orange&quot;)
g = grid((15, 15))
drawgraph(g,
    layout = squaregrid,
    vertexshapesizes = 15,
    vertexfillcolors = [RGB([Luxor.julia_red, Luxor.julia_green,
        Luxor.julia_purple][rand(1:end)]...) for i in 1:nv(g)])
end 600 600</code></pre><p>The following keyword arguments operate in a similar way:</p><ul><li><p><code>vertexstrokeweights</code> : Array | Range | :none</p></li><li><p><code>vertexlabeltextcolors</code> : Array | Range | colorant</p></li><li><p><code>vertexlabelfontsizes</code> : Array | Range | number</p></li><li><p><code>vertexlabelfontfaces</code> : Array  | string</p></li><li><p><code>vertexlabelrotations</code> : Array | Range | number</p></li><li><p><code>vertexlabeloffsetangles</code> : Array | Range | number</p></li><li><p><code>vertexlabeloffsetdistances</code> : Array | Range | number</p></li></ul><p>It&#39;s possible to specify the font faces for vertex labels, but it&#39;s difficult to demonstrate when the documentation is built on machines in the cloud with unknown typographical resources. But anyway:</p><pre><code class="language- hljs">@drawsvg begin
background(&quot;grey10&quot;)
g = smallgraph(:pappus)
sethue(&quot;slateblue&quot;)
drawgraph(g,
    vertexlabels = 1:nv(g),
    vertexshapes = 0,
    vertexlabelfontfaces = [&quot;Times-Roman&quot;, &quot;Courier&quot;, &quot;Helvetica-Bold&quot;],
    vertexlabelfontsizes = 30)
end 600 300</code></pre><h2 id="Edge-options"><a class="docs-heading-anchor" href="#Edge-options">Edge options</a><a id="Edge-options-1"></a><a class="docs-heading-anchor-permalink" href="#Edge-options" title="Permalink"></a></h2><h3 id="edgefunction"><a class="docs-heading-anchor" href="#edgefunction"><code>edgefunction</code></a><a id="edgefunction-1"></a><a class="docs-heading-anchor-permalink" href="#edgefunction" title="Permalink"></a></h3><p>As with <code>vertexfunction</code>, the <code>edgefunction</code> keyword argument allows you to do anything you like when the edges are drawn, and overrides all other <code>edge-</code> keyword arguments. Here, the calculated coordinates of the graph and a path between two vertices aren&#39;t drawn at first, just extracted into vectors for further processing.</p><pre><code class="language- hljs">@drawsvg begin
background(&quot;black&quot;)
sethue(&quot;white&quot;)
g = clique_graph(16, 4)

A = Point[]
B = Point[]

drawgraph(g, layout=stress,
    edgefunction = (edgenumber, edgesrc, edgedest, from, to) -&gt; begin
        push!(A, from),
        push!(A, to)
        end,
    vertexshapes = :none,
    )

route = a_star(g, 6, 29)

drawgraph(g, layout=stress,
    edgelist = route,
    vertexshapes = :none,
    edgefunction = (edgenumber, edgesrc, edgedest, from, to) -&gt; begin
        push!(B, from),
        push!(B, to)
        end)

# Luxor takes over:
setlinejoin(&quot;bevel&quot;)
setline(0.25)

sethue(&quot;grey60&quot;)
@layer begin
    poly(A, :stroke)
end

sethue(&quot;gold&quot;)
setline(4)
@layer begin
    poly(B, :stroke)
end
circle.(B[[begin, end]], 5, :fill)
end 600 400</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This keyword overrides the other <code>edge-</code> keywords.</p></div></div><h3 id="edgelist-and-edgelines"><a class="docs-heading-anchor" href="#edgelist-and-edgelines"><code>edgelist</code> and <code>edgelines</code></a><a id="edgelist-and-edgelines-1"></a><a class="docs-heading-anchor-permalink" href="#edgelist-and-edgelines" title="Permalink"></a></h3><p>A <code>Graphs.EdgeIterator</code> supplied to <code>edgelist</code> makes only the specified edges available for drawing. Otherwise, control which edges are to be drawn by supplying numbers (or a function) to <code>edgelines</code>.</p><pre><code class="language- hljs">@drawsvg begin
background(&quot;grey10&quot;)
sethue(&quot;orange&quot;)
g = grid((15, 15))
drawgraph(g,
    layout = stress,
    vertexshapes = :none,
    edgelines = rand(1:ne(g), 30)
)
end 600 300</code></pre><p><code>edgelist</code> is useful for drawing paths - a sequence of edges. For example, if you use <code>a_star()</code> to find the shortest path between two vertices, you can draw the edges with this keyword. It&#39;s useful to draw the graph twice, once with all edges, once with selected edges.</p><pre><code class="language- hljs">@drawsvg begin
background(&quot;grey10&quot;)
g = grid((15, 15))

astar = a_star(g, 1, nv(g))

sethue(&quot;orange&quot;)
drawgraph(g,
    layout = stress,
    vertexshapes = :none)

sethue(&quot;cyan&quot;)
drawgraph(g,
    layout = stress,
    vertexshapes = :none,
    edgestrokeweights = 5,
    edgelist = astar)
end 600 300</code></pre><p>For more interesting arrows for edges, Luxor&#39;s arrows are available, and you can define functions to create all kinds of graphical deatil:</p><pre><code class="language- hljs">gd = DiGraph() 
add_vertices!(gd, 4) 
add_edge!(gd, 1, 2) 
add_edge!(gd, 1, 3) 
add_edge!(gd, 2, 3) 
add_edge!(gd, 1, 4) # vertex 1 to vertex 4 
add_edge!(gd, 4, 1) # vertex 4 to vertex 1 

@drawsvg begin 
    background(&quot;grey10&quot;) 
    sethue(&quot;thistle1&quot;) 
    drawgraph(gd, vertexlabels = [1, 2, 3, 4],  
        edgefunction = (n, s, d, f, t) -&gt; begin 
            arrow(f, t, [10, 10],  
            decoration = 0.75, 
            decorate = () -&gt; begin 
                sethue(HSB(60n, 0.7, 0.8)) 
                ngon(O, 10, 3, 0, :fill)  
            end, 
            arrowheadfunction= (f, t, a) -&gt; () 
            )    
        end 
    ) 
end 600 300 </code></pre><pre><code class="language- hljs">@drawsvg begin
background(&quot;grey10&quot;)
g = star_graph(12)
fontsize(20)
sethue(&quot;slateblue&quot;)
drawgraph(g,
    layout=spring,
    vertexshapes = 0,
    vertexlabels = 1:nv(g),
    vertexlabelfontsizes = 12,
    edgestrokecolors = distinguishable_colors(ne(g)),
    edgelines = (k, s, d, f, t) -&gt;
        arrow(f, between(f, t, .95), [20, -45],
            linewidth = 5,
            arrowheadlength = 15,
            arrowheadangle = π/7,
            decorate = () -&gt; begin
                    sethue(&quot;purple&quot;)
                    circle(O, 15, :fill)
                    sethue(&quot;white&quot;)
                    text(string(k), angle = -getrotation(), halign = :center, valign=:middle)
                end,
            decoration = .7))
end 600 400</code></pre><h3 id="Edge-labels"><a class="docs-heading-anchor" href="#Edge-labels">Edge labels</a><a id="Edge-labels-1"></a><a class="docs-heading-anchor-permalink" href="#Edge-labels" title="Permalink"></a></h3><p>Use <code>edgelabels</code>, <code>edgelabelcolors</code>, <code>edgelabelrotations</code>, etc. to control the appearance of the labels alongside edges.</p><pre><code class="language- hljs">@drawsvg begin
background(&quot;grey10&quot;)
g = smallgraph(:dodecahedral)
g = complete_graph(5)
sethue(&quot;orange&quot;)
fontsize(20)
drawgraph(g, layout=stress,
    vertexshapes = :none,
    vertexlabels = &quot;vertex&quot;,
    vertexlabeltextcolors = colorant&quot;cyan&quot;,
    edgelabels = [&quot;edge&quot;],
    edgestrokecolors = colorant&quot;orange&quot;,
    edgelabelcolors = colorant&quot;pink&quot;,
    )
end 600 500</code></pre><p><code>edgelabels</code> can also be a dictionary, where the keys are tuples: <code>(src, dst)</code>, and the values are the text labels.</p><pre><code class="language- hljs">g = complete_graph(5)
edgelabeldict = Dict()
n = nv(g)
for i in 1:n
    for j in 1:n
        edgelabeldict[(i, j)] = &quot;($i, $j)&quot;
    end
end

@drawsvg begin
    background(&quot;grey10&quot;)
    drawgraph(g, layout=stress,
        vertexshapes = :circle,
        vertexlabels = 1:n,
        edgestrokecolors = colorant&quot;orange&quot;,
        edgelabelcolors = colorant&quot;white&quot;,
        edgelabels = edgelabeldict)
end 600 350</code></pre><p>The <code>edgelabels</code> keyword argument can also accept a function with five arguments: <code>edgenumber</code>, <code>source</code>, <code>destination</code>, <code>from</code> and <code>to</code>. In this example, the graphical distances between the two vertex positions provide the annotations for each edge.</p><pre><code class="language- hljs">@drawsvg begin
background(&quot;grey10&quot;)
g = smallgraph(:dodecahedral)
g = complete_graph(5)
fontsize(20)
drawgraph(g, layout=stress,
    vertexshapes = :none,
    edgestrokecolors = colorant&quot;orange&quot;,
    edgelabels = (k, src, dest, f, t) -&gt; begin
        @layer begin
            sethue(&quot;white&quot;)
            θ = slope(f, t)
            text(string(round(distance(f, t), digits=1)),
                midpoint(f, t),
                angle=θ,
                halign=:center)
        end
    end)
end 600 500</code></pre><p>The more code you&#39;re prepared to write, the more elaborate your labels can be:</p><pre><code class="language- hljs">sources      = [1,2,1]
destinations = [2,3,3]
weights      = [0.5, 0.8, 2.0]
g = SimpleWeightedGraph(sources, destinations, weights)
@drawsvg begin
background(&quot;grey10&quot;)
sethue(&quot;gold&quot;)
drawgraph(g,
    vertexlabels = 1:nv(g),
    vertexshapesizes = 20,
    vertexlabelfontsizes = 30,
    edgecurvature = 10,
    edgegaps = 25,
    edgelabels = (edgenumber, edgesrc, edgedest, from, to) -&gt; begin
        @layer begin
            sethue(&quot;black&quot;)
            box(midpoint(from, to), 50, 30, :fill)
        end
        box(midpoint(from, to), 50, 30, :stroke)
        fontsize(16)
        text(string(get_weight(g, edgesrc, edgedest)),
            midpoint(from, to),
            halign=:center,
            valign=:middle)
    end)
end 600 300</code></pre><p>For directed weighted graphs, each edge can have two weights. This makes it slightly more difficult to draw the labels automatically. You could write an edge labelling function that calculates the slope of the edge and positions the label accordingly:</p><pre><code class="language-julia hljs">function f(edgenumber, edgesrc, edgedest, from::Point, to::Point)
    sl = slope(from, to)
    wt = g.weights[edgesrc, edgedest]
    if sl &gt; π
        label(string(wt), :e, midpoint(from, to))
    else
        label(string(wt), :w, midpoint(from, to))
    end
end 

...
    edgelabels=f,
...</code></pre><h3 id="edgelist"><a class="docs-heading-anchor" href="#edgelist"><code>edgelist</code></a><a id="edgelist-1"></a><a class="docs-heading-anchor-permalink" href="#edgelist" title="Permalink"></a></h3><p>This example draws the graph more than once; once with all the edges, once with only the edges in <code>edgelist</code>, where <code>edgelist</code> is the path from vertex 15 to vertex 17, drawn in a pale translucent yellow, and once to draw the vertices on the path &quot;X marks the spot&quot; cyan-colored crosses.</p><pre><code class="language- hljs">@drawsvg begin
    background(&quot;grey10&quot;)
    g = smallgraph(:karate)
    sethue(&quot;slateblue&quot;)

    drawgraph(g, layout = stress,
        vertexlabels = 1:nv(g),
        vertexshapes = :circle,
        vertexshapesizes = 10,
        vertexlabelfontsizes = 10)

    astar = a_star(g, 15, 17)

    drawgraph(g,
        layout=stress,
        vertexshapes = :none,
        edgelist = astar,
        edgestrokecolors=RGBA(1, 1, 0, 0.5),
        edgestrokeweights=10)

    drawgraph(g,
        layout=stress,
        edgelines=0,
        vertexshapes = (v) -&gt; v ∈ src.(astar) &amp;&amp; polycross(O, 20, 4, 0.5, π/4, :fill),
             vertexfillcolors = (v) -&gt; v ∈ src.(astar) &amp;&amp; colorant&quot;cyan&quot;
        )
end 600 600</code></pre><h3 id="edgecurvature-and-edgecaps"><a class="docs-heading-anchor" href="#edgecurvature-and-edgecaps"><code>edgecurvature</code> and <code>edgecaps</code></a><a id="edgecurvature-and-edgecaps-1"></a><a class="docs-heading-anchor-permalink" href="#edgecurvature-and-edgecaps" title="Permalink"></a></h3><p><code>edgecurvature</code> determines the curvature of the edges, and <code>edgegaps</code> sets the distance between the tip of the arrowhead and the vertex position. Units, as everywhere in Karnak and Luxor, are points/pixels (1 point is 0.3527mm).</p><pre><code class="language- hljs">g = grid((3, 3))

# add some self-loops
for e in edges(g)
    add_edge!(g, src(e), src(e))
    add_edge!(g, dst(e), dst(e))
end

@drawsvg begin
    background(&quot;grey10&quot;)
    sethue(&quot;white&quot;)
    for c in 1:10
        drawgraph(g,
            margin=70,
            vertexshapes = :none,
            edgegaps = 3c,
            edgecurvature = 3c,
            edgestrokecolors = HSB(36c, .8, .8),
            edgestrokeweights = 0.5,
            layout=squaregrid)
    end
end 600 500</code></pre><h3 id="edgestrokecolors-and-edgestrokeweights"><a class="docs-heading-anchor" href="#edgestrokecolors-and-edgestrokeweights"><code>edgestrokecolors</code> and <code>edgestrokeweights</code></a><a id="edgestrokecolors-and-edgestrokeweights-1"></a><a class="docs-heading-anchor-permalink" href="#edgestrokecolors-and-edgestrokeweights" title="Permalink"></a></h3><pre><code class="language- hljs">g = barbell_graph(3, 3)
@drawsvg begin
    background(&quot;grey10&quot;)
    fontsize(30)
    sethue(&quot;white&quot;)
    drawgraph(g,
        layout=stress,
        edgelabels = 1:ne(g),
        edgecurvature = 10,
        edgestrokeweights = 2 * (1:ne(g)),
        edgelabelcolors = colorant&quot;white&quot;,
        edgestrokecolors= (n, from, to, edgesrc, edgedest) -&gt; HSB(rescale(n, 1, ne(g), 0, 359), .8, .8))
end 600 500</code></pre><h3 id="edgedashpatterns"><a class="docs-heading-anchor" href="#edgedashpatterns"><code>edgedashpatterns</code></a><a id="edgedashpatterns-1"></a><a class="docs-heading-anchor-permalink" href="#edgedashpatterns" title="Permalink"></a></h3><p>Line dashes work the same as in Luxor.jl, ie they&#39;re numbers in an array, with line length following by space length. If you want to alternate between dash patterns, supply an array of pattern arrays.</p><pre><code class="language- hljs">g = grid((5, 5))
@drawsvg begin
    background(&quot;grey10&quot;)
    sethue(&quot;white&quot;)
    drawgraph(g,
        layout=squaregrid,
        edgestrokeweights = 5,
        edgelabels = (edgenumber, edgesrc, edgedest, from::Point, to::Point) -&gt;
            begin
                labeltext = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;][mod1(edgenumber, end)]
                label(labeltext, :se, midpoint(from, to), offset=5)
            end,
        edgedashpatterns = [[20, 10, 1, 10], [20, 10], [0.5, 10]],
        edgelabelfontsizes = 20,
        vertexshapesizes = 2,
        edgestrokecolors=(edgenumber, from, to, src, dst) -&gt;
            HSB(rescale(edgenumber, 1, ne(g), 0, 359), .8, .8)
          )
end 600 400</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../basics/">« Basic graphs</a><a class="docs-footer-nextpage" href="../examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.0 on <span class="colophon-date" title="Friday 6 October 2023 13:27">Friday 6 October 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
